var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 *
 * Wechaty: Wechat for Bot. and for human who talk to bot/robot
 *
 * Class StateSwitch
 * Licenst: Apache-2.0
 * https://github.com/huan/state-switch
 *
 * Helper Class for Manage State Change
 */
import NOP from 'nop';
import { VERSION } from './version';
export class StateSwitch {
    constructor(_name = 'Lock', logInstance) {
        this._name = _name;
        if (logInstance) {
            this.setLog(logInstance); // init log, should be a Brolog or Npmlog instance
        }
        else {
            this.setLog(null);
        }
        this.log.verbose('StateSwitch', 'constructor(name=%s)', _name);
        this._on = false;
        this._pending = false;
        /**
         * for ready()
         */
        this.offPromise = Promise.resolve();
        this.onPromise = new Promise(resolve => {
            this.onResolver = resolve;
        });
        this.offResolver = NOP;
    }
    version() {
        return VERSION;
    }
    setLog(logInstance) {
        if (logInstance) {
            this.log = logInstance;
        }
        else {
            /* eslint @typescript-eslint/no-unused-vars: off */
            this.log = {
                silly(..._) { },
                verbose(..._) { },
                warn(..._) { },
                error(..._) { },
            };
        }
    }
    /**
     * set/get ON state
     */
    on(state) {
        if (state) {
            this.log.verbose('StateSwitch', '<%s> on(%s) <- (%s)', this._name, state, this.on());
            this._on = true;
            this._pending = (state === 'pending');
            /**
             * for ready()
             */
            if (this.offResolver === NOP) {
                this.offPromise = new Promise(resolve => (this.offResolver = resolve));
            }
            if (state === true && this.onResolver !== NOP) {
                this.onResolver();
                this.onResolver = NOP;
            }
            return;
        }
        const on = this._on
            ? this._pending ? 'pending' : true
            : false;
        this.log.silly('StateSwitch', '<%s> on() is %s', this._name, on);
        return on;
    }
    /**
     * set/get OFF state
     */
    off(state) {
        if (state) {
            this.log.verbose('StateSwitch', '<%s> off(%s) <- (%s)', this._name, state, this.off());
            this._on = false;
            this._pending = (state === 'pending');
            /**
             * for ready()
             */
            if (this.onResolver === NOP) {
                this.onPromise = new Promise(resolve => (this.onResolver = resolve));
            }
            if (state === true && this.offResolver !== NOP) {
                this.offResolver();
                this.offResolver = NOP;
            }
            return;
        }
        const off = !this._on
            ? this._pending ? 'pending' : true
            : false;
        this.log.silly('StateSwitch', '<%s> off() is %s', this._name, off);
        return off;
    }
    ready(state = 'on', noCross = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.verbose('StateSwitch', '<%s> ready(%s, %s)', this._name, state, noCross);
            if (state === 'on') {
                if (this._on === false && noCross === true) {
                    throw new Error(`ready(on) but the state is off. call ready(on, true) to force crossWait`);
                }
                yield this.onPromise;
            }
            else { // state === off
                if (this._on === true && noCross === true) {
                    throw new Error('ready(off) but the state is on. call ready(off, true) to force crossWait');
                }
                yield this.offPromise;
            }
            this.log.silly('StateSwitch', '<%s> ready(%s, %s) resolved.', this._name, state, noCross);
        });
    }
    /**
     * does the state is not stable(in process)?
     */
    pending() {
        this.log.silly('StateSwitch', '<%s> pending() is %s', this._name, this._pending);
        return this._pending;
    }
    /**
     * get the client name
     */
    name() {
        return this._name;
    }
}
export { VERSION, };
export default StateSwitch;
//# sourceMappingURL=state-switch.js.map