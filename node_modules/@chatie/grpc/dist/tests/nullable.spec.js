#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const util_1 = __importDefault(require("util"));
const grpc_1 = __importDefault(require("grpc"));
const src_1 = require("../src/");
const puppet_server_impl_1 = require("./puppet-server-impl");
const wrappers_pb_1 = require("google-protobuf/google/protobuf/wrappers_pb");
const SERVER_ENDPOINT = '127.0.0.1:8788';
const ID = 'test-id';
const ALIAS = 'test-alias';
const contactAlias = (call, callback) => {
    const id = call.request.getId();
    let aliasWrapper = call.request.getAlias();
    if (aliasWrapper) {
        /**
         * Set alias, return void
         */
        const alias = aliasWrapper.getValue();
        if (alias !== ALIAS) {
            throw new Error(`alias argument value error: ${alias} not equal to ${ALIAS}`);
        }
        callback(null, new src_1.ContactAliasResponse());
    }
    else {
        /**
         * Get alias, return alias
         */
        aliasWrapper = new wrappers_pb_1.StringValue();
        aliasWrapper.setValue(id + ALIAS);
        const response = new src_1.ContactAliasResponse();
        response.setAlias(aliasWrapper);
        callback(null, response);
    }
};
tstest_1.test('use StringValue to support nullable values', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const puppetServerImplTest = Object.assign(Object.assign({}, puppet_server_impl_1.puppetServerImpl), { contactAlias });
    const server = new grpc_1.default.Server();
    server.addService(src_1.PuppetService, puppetServerImplTest);
    // FIXME: Huan(202002) if the port has been used by another grpc server, this will still bind with succeed!
    // The result will be one port binded by two grpc server, and they are all working well...
    const success = server.bind(SERVER_ENDPOINT, grpc_1.default.ServerCredentials.createInsecure());
    if (!success) {
        t.fail(`server bind to ${SERVER_ENDPOINT} failed.`);
        return;
    }
    server.start();
    const client = new src_1.PuppetClient(SERVER_ENDPOINT, grpc_1.default.credentials.createInsecure());
    const contactAliasPromise = util_1.default.promisify(client.contactAlias.bind(client));
    /**
     * Get alias
     */
    {
        const request = new src_1.ContactAliasRequest();
        request.setId(ID);
        const response = yield contactAliasPromise(request);
        const aliasWrapper = response.getAlias();
        t.ok(aliasWrapper, 'Should return an aliasWrapper');
        if (aliasWrapper) {
            let alias = aliasWrapper.getValue();
            t.equal(alias, ID + ALIAS, 'should get the right alias value');
        }
        else {
            t.fail('can not get alias value');
        }
    }
    /**
     * Set alias
     */
    {
        const aliasWrapper = new wrappers_pb_1.StringValue();
        aliasWrapper.setValue(ALIAS);
        const request = new src_1.ContactAliasRequest();
        request.setId(ID);
        request.setAlias(aliasWrapper);
        const response = yield contactAliasPromise(request);
        const nullAliasWrapper = response.getAlias();
        t.notOk(nullAliasWrapper, 'should return undefined for null value');
    }
    const tryShutdown = util_1.default.promisify(server.tryShutdown.bind(server));
    yield tryShutdown();
    const forceShutdown = util_1.default.promisify(server.forceShutdown.bind(server));
    setImmediate(() => forceShutdown());
}));
//# sourceMappingURL=nullable.spec.js.map