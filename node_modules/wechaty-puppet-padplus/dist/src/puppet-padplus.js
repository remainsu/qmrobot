"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __importDefault(require("util"));
const path_1 = __importDefault(require("path"));
const array_flatten_1 = require("array-flatten");
const wechaty_puppet_1 = require("wechaty-puppet");
const config_1 = require("./config");
const request_queue_1 = require("./padplus-manager/api-request/request-queue");
const padplus_manager_1 = __importDefault(require("./padplus-manager/padplus-manager"));
const schemas_1 = require("./schemas");
const room_convertor_1 = require("./convert-manager/room-convertor");
const room_event_join_message_parser_1 = require("./pure-function-helpers/room-event-join-message-parser");
const room_event_leave_message_parser_1 = require("./pure-function-helpers/room-event-leave-message-parser");
const room_event_topic_message_parser_1 = require("./pure-function-helpers/room-event-topic-message-parser");
const friendship_event_message_parser_1 = require("./pure-function-helpers/friendship-event-message-parser");
const pure_function_helpers_1 = require("./pure-function-helpers");
const contact_raw_payload_parser_1 = require("./pure-function-helpers/contact-raw-payload-parser");
const xml_to_json_1 = require("./pure-function-helpers/xml-to-json");
const contact_convertor_1 = require("./convert-manager/contact-convertor");
const util_2 = __importDefault(require("./utils/util"));
const message_mini_program_payload_parser_1 = require("./pure-function-helpers/message-mini-program-payload-parser");
const message_convertor_1 = require("./convert-manager/message-convertor");
const PRE = 'PuppetPadplus';
class PuppetPadplus extends wechaty_puppet_1.Puppet {
    constructor(options = {}) {
        super(options);
        this.options = options;
        this.leaveEventKey = '';
        const token = this.options.token || config_1.padplusToken();
        const name = this.options.name;
        if (token) {
            this.manager = new padplus_manager_1.default({
                endpoint: this.options.endpoint || config_1.GRPC_ENDPOINT,
                name,
                token,
            });
        }
        else {
            config_1.log.error(PRE, `can not get token info from options for start grpc gateway.`);
            throw new Error(`can not get token info.`);
        }
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.info(PRE, `start()`);
            this.state.on('pending');
            yield this.startManager(this.manager);
            this.state.on(true);
        });
    }
    startManager(manager) {
        const _super = Object.create(null, {
            login: { get: () => super.login }
        });
        return __awaiter(this, void 0, void 0, function* () {
            manager.on('scan', (url, status) => __awaiter(this, void 0, void 0, function* () {
                const eventScanPayload = {
                    qrcode: url,
                    status,
                };
                this.emit('scan', eventScanPayload);
            }));
            manager.on('login', (loginData) => __awaiter(this, void 0, void 0, function* () {
                yield _super.login.call(this, loginData.userName);
                yield this.manager.syncContacts();
            }));
            manager.setMemory(this.memory);
            manager.on('message', msg => this.onMessage(msg));
            manager.on('ready', () => this.emit('ready', { data: 'ready' }));
            manager.on('reset', (reason) => {
                const eventResetPayload = {
                    data: reason,
                };
                this.emit('reset', eventResetPayload);
            });
            manager.on('heartbeat', (data) => {
                const eventWatchdogPayload = {
                    data,
                };
                this.emit('heartbeat', eventWatchdogPayload);
            });
            manager.on('logout', (reason) => this.logout(true, reason));
            manager.on('room-leave', (data) => {
                this.deduplicateRoomLeaveEvent(data);
            });
            manager.on('error', (err) => {
                const eventErrorPayload = {
                    data: err.toString(),
                };
                this.emit('error', eventErrorPayload);
            });
            yield manager.start();
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.info(PRE, 'stop()');
            if (!this.manager) {
                throw new Error('no padplus manager');
            }
            if (this.state.off()) {
                config_1.log.silly(PRE, 'stop() is called on a OFF puppet. await ready(off) and return.');
                yield this.state.ready('off');
                return;
            }
            this.state.off('pending');
            yield this.logout(true, 'logout in wechaty');
            yield this.manager.stop();
            this.manager.removeAllListeners();
            this.state.off(true);
            config_1.log.silly(PRE, `stop() finished`);
        });
    }
    /**
     * Three type for logout case:
     *   - case 1: logout by WeChat App, need reset
     *   - case 2: logout by call API, need reset
     *   - case 3: logout by call reset, no need reset
     * @param force case 1: true, case 2: false, case 3: true
     * @param reason
     */
    logout(force, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.info(PRE, `logout(${force}, ${reason})`);
            if (!this.id) {
                config_1.log.silly(PRE, 'logout() this.id not exist');
                return;
            }
            if (!force) {
                yield this.manager.logout(this.selfId());
                reason = 'logout by call logout() method';
            }
            const eventLogoutPayload = {
                contactId: this.selfId(),
                data: reason ? reason : 'unknow reason',
            };
            this.emit('logout', eventLogoutPayload);
            this.id = undefined;
            if (reason !== 'logout in wechaty') {
                const eventResetPayload = {
                    data: 'padplus reset',
                };
                this.emit('reset', eventResetPayload);
            }
        });
    }
    onMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageType = message.msgType;
            if (pure_function_helpers_1.isRoomId(message.fromUserName)) {
                yield this.roomRawPayload(message.fromUserName);
            }
            else {
                yield this.contactRawPayload(message.fromUserName);
            }
            const eventMessagePayload = {
                messageId: message.msgId,
            };
            switch (messageType) {
                case schemas_1.PadplusMessageType.Sys:
                    yield Promise.all([
                        this.onRoomJoinEvent(message),
                        this.onRoomLeaveEvent(message),
                        this.onRoomTopicEvent(message),
                        this.onFriendshipEvent(message),
                    ]);
                    break;
                case schemas_1.PadplusMessageType.VerifyMsg:
                    yield this.onFriendshipEvent(message);
                    break;
                case schemas_1.PadplusMessageType.Recalled:
                    this.emit('message', eventMessagePayload);
                    yield this.onRoomJoinEvent(message);
                    break;
                case schemas_1.PadplusMessageType.Text:
                    yield this.onFriendshipEvent(message);
                    this.emit('message', eventMessagePayload);
                    break;
                case schemas_1.PadplusMessageType.App:
                    yield this.onRoomInvitation(message);
                    break;
                case schemas_1.PadplusMessageType.Contact:
                case schemas_1.PadplusMessageType.Image:
                case schemas_1.PadplusMessageType.Deleted:
                case schemas_1.PadplusMessageType.Voice:
                case schemas_1.PadplusMessageType.SelfAvatar:
                case schemas_1.PadplusMessageType.PossibleFriendMsg:
                case schemas_1.PadplusMessageType.ShareCard:
                case schemas_1.PadplusMessageType.Video:
                case schemas_1.PadplusMessageType.Emoticon:
                case schemas_1.PadplusMessageType.Location:
                case schemas_1.PadplusMessageType.VoipMsg:
                case schemas_1.PadplusMessageType.StatusNotify:
                case schemas_1.PadplusMessageType.VoipNotify:
                case schemas_1.PadplusMessageType.VoipInvite:
                case schemas_1.PadplusMessageType.MicroVideo:
                case schemas_1.PadplusMessageType.SelfInfo:
                case schemas_1.PadplusMessageType.SysNotice:
                case schemas_1.PadplusMessageType.N11_2048:
                case schemas_1.PadplusMessageType.N15_32768:
                default:
                    this.emit('message', eventMessagePayload);
                    break;
            }
        });
    }
    /**
     * ========================
     *     TAG SECTION
     * ========================
     */
    tagContactAdd(name, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `tagContactAdd(${name}, ${contactId})`);
            const tagId = yield this.manager.getOrCreateTag(name);
            return this.manager.addTag(tagId, contactId);
        });
    }
    tagContactRemove(name, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `tagContactRemove(${name}, ${contactId})`);
            const tagId = yield this.manager.getOrCreateTag(name);
            yield this.manager.removeTag(tagId, contactId);
        });
    }
    tagContactDelete(name) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `tagContactDelete(${name})`);
            const tagId = yield this.manager.getOrCreateTag(name);
            yield this.manager.deleteTag(tagId);
        });
    }
    tagContactList(contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `tagContactList()`);
            const tags = yield this.manager.tags(contactId);
            return tags.map(tag => tag.name);
        });
    }
    /**
     * ========================
     *     CONTACT SECTION
     * ========================
     */
    contactSelfQRCode() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactSelfQrcode()`);
            return this.manager.contactSelfQrcode();
        });
    }
    contactSelfName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactSelfName(${name})`);
            yield this.manager.contactSelfName(name);
        });
    }
    contactSelfSignature(signature) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactSelfSignature(${signature})`);
            yield this.manager.contactSelfSignature(signature);
        });
    }
    contactSelfInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactSelfInfo()`);
            return this.manager.contactSelfInfo();
        });
    }
    contactAlias(contactId, alias) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactAlias(), contactId: ${contactId}, alias : ${alias}`);
            if (typeof alias === 'undefined') {
                const payload = yield this.contactPayload(contactId);
                return payload.alias || '';
            }
            if (!this.manager) {
                throw new Error(`no padplus manage.`);
            }
            yield this.manager.setContactAlias(contactId, alias || '');
        });
    }
    contactAvatar(contactId, file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (file) {
                if (contactId !== this.selfId()) {
                    throw new Error(`can not set avatar for others.`);
                }
                if (!this.manager) {
                    throw new Error(`no padplus manager.`);
                }
                return;
            }
            const payload = yield this.contactRawPayload(contactId);
            if (!payload || !payload.bigHeadUrl) {
                throw new Error(`can not find contact.`);
            }
            const fileBox = wechaty_puppet_1.FileBox.fromUrl(payload.bigHeadUrl, `wechaty-contact-avatar-${payload.userName}.jpg`);
            return fileBox;
        });
    }
    contactList() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactList()`);
            if (!this.manager) {
                throw new Error(`no padplus manager.`);
            }
            const selfId = this.selfId();
            const contactIds = yield this.manager.getContactIdList(selfId);
            return contactIds;
        });
    }
    contactRawPayload(contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const payload = yield this.manager.getContactPayload(contactId);
            return payload;
        });
    }
    contactRawPayloadParser(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `contactRawPayloadParser()`);
            const payload = contact_raw_payload_parser_1.contactRawPayloadParser(rawPayload);
            return payload;
        });
    }
    /**
     * =========================
     *    FRIENDSHIP SECTION
     * =========================
     */
    onFriendshipEvent(message) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, 'onPadplusMessageFriendshipEvent({id=%s})', message.msgId);
            /**
             * 1. Look for friendship confirm event
             */
            const friendshipConfirmContactId = friendship_event_message_parser_1.friendshipConfirmEventMessageParser(message);
            /**
             * 2. Look for friendship receive event
             */
            const friendshipReceiveContactId = yield friendship_event_message_parser_1.friendshipReceiveEventMessageParser(message);
            /**
             * 3. Look for friendship verify event
             */
            const friendshipVerifyContactId = friendship_event_message_parser_1.friendshipVerifyEventMessageParser(message);
            if (friendshipConfirmContactId
                || friendshipReceiveContactId
                || friendshipVerifyContactId) {
                // Maybe load contact here since we know a new friend is added
                if (!this.manager) {
                    throw new Error(`no manager.`);
                }
                const friendship = yield pure_function_helpers_1.friendshipRawPayloadParser(message);
                if (!friendship) {
                    config_1.log.silly(PRE, `not friendship : ${message.msgId}`);
                    return;
                }
                const { msgId } = message;
                yield this.manager.saveFriendship(msgId, friendship);
                const eventFriendshipPayload = {
                    friendshipId: msgId,
                };
                this.emit('friendship', eventFriendshipPayload);
            }
        });
    }
    friendshipSearchPhone(phone) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `friendshipSearchPhone(${phone})`);
            if (!this.manager) {
                throw new Error('no padplus manager');
            }
            const isPhoneNumber = util_2.default(phone);
            if (!isPhoneNumber) {
                config_1.log.error(PRE, `Some wrong with your phone number, please check it again.`);
                return null;
            }
            else {
                const searchContact = yield this.manager.searchContact(phone, true);
                if (!pure_function_helpers_1.isStrangerV1(searchContact.v1) && !pure_function_helpers_1.isStrangerV2(searchContact.v2)) {
                    return searchContact.v1;
                }
                if (!this.manager || !this.manager.cacheManager) {
                    throw new Error(`no cache manager`);
                }
                const contactPayload = contact_convertor_1.convertSearchContactToContact(searchContact, isPhoneNumber);
                yield this.manager.cacheManager.setContact(phone, contactPayload);
                return phone;
            }
        });
    }
    friendshipSearchWeixin(weixin) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `friendshipSearchWeixin(${weixin})`);
            if (!this.manager) {
                throw new Error('no padplus manager');
            }
            const searchContact = yield this.manager.searchContact(weixin, true);
            if (!pure_function_helpers_1.isStrangerV1(searchContact.v1) && !pure_function_helpers_1.isStrangerV2(searchContact.v2)) {
                return searchContact.v1;
            }
            if (!this.manager || !this.manager.cacheManager) {
                throw new Error(`no cache manager`);
            }
            const contactPayload = contact_convertor_1.convertSearchContactToContact(searchContact);
            yield this.manager.cacheManager.setContact(weixin, contactPayload);
            return weixin;
        });
    }
    friendshipAdd(contactId, hello) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `friendshipAdd(${contactId}, ${hello})`);
            if (!this.manager) {
                throw new Error('no padplus manager');
            }
            const searchContact = yield this.manager.searchContact(contactId);
            if (searchContact === null) {
                throw new Error(`Can not search friend by contact id : ${contactId}`);
            }
            /**
             * If the contact is not stranger, than using WXSearchContact can get userName
             */
            if (searchContact.wxid !== '' && !pure_function_helpers_1.isStrangerV1(searchContact.v1) && !pure_function_helpers_1.isStrangerV2(searchContact.v2)) {
                config_1.log.silly(PRE, `friendshipAdd ${contactId} has been friend with bot, no need to send friend request!`);
                return;
            }
            let strangerV1;
            let strangerV2;
            if (pure_function_helpers_1.isStrangerV1(searchContact.v1)) {
                strangerV1 = searchContact.v1;
                strangerV2 = searchContact.v2;
            }
            else if (pure_function_helpers_1.isStrangerV2(searchContact.v2)) {
                strangerV1 = searchContact.v1;
                strangerV2 = searchContact.v2;
            }
            else {
                throw new Error('stranger neither v1 nor v2!');
            }
            const isPhoneNumber = contactId.match(/^[1]([3-9])[0-9]{9}$/);
            const res = yield this.manager.addFriend(contactId, hello, isPhoneNumber ? schemas_1.SearchContactTypeStatus.MOBILE : schemas_1.SearchContactTypeStatus.WXID, // default to wxid
            strangerV1 || '', strangerV2 || '');
            if (res && res.status !== '0') {
                throw new Error(`add friend failed.`);
            }
            else if (res && res.status === '0') {
                config_1.log.silly(PRE, `add friend request success.`);
            }
        });
    }
    friendshipAccept(friendshipId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `friendshipAccept(${friendshipId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const payload = yield this.manager.getFriendship(friendshipId);
            if (!payload || payload.type !== wechaty_puppet_1.FriendshipType.Receive) {
                throw new Error(`can not find friendship payload ${JSON.stringify(payload)} or friendship type ${payload && payload.type} error.`);
            }
            const { contactId, scene, stranger, ticket } = payload;
            if (!stranger || !ticket) {
                throw new Error(`friendship data error, stranger or ticket is null.`);
            }
            yield this.manager.confirmFriendship(contactId, stranger, ticket, (scene && scene.toString()) || '3');
        });
    }
    friendshipRawPayload(friendshipId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `friendshipRawPayload(${friendshipId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const payload = yield this.manager.getFriendship(friendshipId);
            if (payload) {
                return payload;
            }
            throw new Error(`can not find friendship.`);
        });
    }
    friendshipRawPayloadParser(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `friendshipRawPayloadParser(${util_1.default.inspect(rawPayload)})`);
            return rawPayload;
        });
    }
    friendshipPayload(friendshipId, friendshipPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly('PadPlus', 'friendshipPayload(%s)', friendshipId, friendshipPayload
                ? ',' + JSON.stringify(friendshipPayload)
                : '');
            if (typeof friendshipPayload === 'object') {
                const payloadCache = yield this.manager.getFriendship(friendshipId);
                if (!payloadCache) {
                    yield this.manager.saveFriendship(friendshipId, friendshipPayload);
                }
                return;
            }
            const rawPayload = yield this.friendshipRawPayload(friendshipId);
            const payload = yield this.friendshipRawPayloadParser(rawPayload);
            return payload;
        });
    }
    /**
     * =========================
     *   MESSAGE IMAGE SECTION
     * =========================
     */
    messageImage(messageId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageImage(${messageId})`);
            const rawPayload = yield this.messageRawPayload(messageId);
            if (!rawPayload || !rawPayload.url) {
                throw new Error(`can not find message raw payload by id : ${messageId}`);
            }
            switch (type) {
                case wechaty_puppet_1.ImageType.Thumbnail:
                    return wechaty_puppet_1.FileBox.fromUrl(rawPayload.url);
                case wechaty_puppet_1.ImageType.HD:
                    throw new Error(`HD not support!`);
                case wechaty_puppet_1.ImageType.Artwork:
                    let content = rawPayload.content;
                    const mediaData = {
                        appMsgType: 0,
                        content,
                        contentType: 'img',
                        createTime: rawPayload.createTime,
                        fileName: rawPayload.fileName || '',
                        fromUserName: rawPayload.fromUserName,
                        msgId: rawPayload.msgId,
                        msgType: rawPayload.msgType,
                        src: rawPayload.url,
                        toUserName: rawPayload.toUserName,
                    };
                    const data = yield request_queue_1.RequestQueue.exec(() => this.manager.loadRichMediaData(mediaData));
                    if (data && data.src) {
                        const name = this.getNameFromUrl(data.src);
                        let src;
                        if (escape(data.src).indexOf('%u') === -1) {
                            src = data.src;
                        }
                        else {
                            src = encodeURI(data.src);
                        }
                        return wechaty_puppet_1.FileBox.fromUrl(src, name);
                    }
                    else {
                        throw new Error(`Can not get media data url by this message id: ${messageId}`);
                    }
                default:
                    throw new Error(`this type : ${type} is wrong.`);
            }
        });
    }
    /**
     * ========================
     *     MESSAGE SECTION
     * ========================
     */
    messageFile(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageFile(${messageId})`);
            const rawPayload = yield this.messageRawPayload(messageId);
            const payload = yield this.messagePayload(messageId);
            let filename = payload.filename || payload.id;
            const type = payload.type === wechaty_puppet_1.MessageType.Image ? 'img' : payload.type === wechaty_puppet_1.MessageType.Video ? 'video' : 'file';
            switch (payload.type) {
                case wechaty_puppet_1.MessageType.Image:
                case wechaty_puppet_1.MessageType.Attachment:
                case wechaty_puppet_1.MessageType.Video:
                    let content = rawPayload.content;
                    const mediaData = {
                        appMsgType: type === 'file' ? 6 : 0,
                        content,
                        contentType: type,
                        createTime: rawPayload.createTime,
                        fileName: rawPayload.fileName || '',
                        fromUserName: rawPayload.fromUserName,
                        msgId: rawPayload.msgId,
                        msgType: rawPayload.msgType,
                        src: rawPayload.url,
                        toUserName: rawPayload.toUserName,
                    };
                    const data = yield request_queue_1.RequestQueue.exec(() => this.manager.loadRichMediaData(mediaData));
                    if (data && data.src) {
                        const name = this.getNameFromUrl(data.src);
                        let src;
                        if (escape(data.src).indexOf('%u') === -1) {
                            src = data.src;
                        }
                        else {
                            src = encodeURI(data.src);
                        }
                        return wechaty_puppet_1.FileBox.fromUrl(src, name);
                    }
                    else {
                        throw new Error(`Can not get media data url by this message id: ${messageId}`);
                    }
                case wechaty_puppet_1.MessageType.Emoticon:
                    if (rawPayload && rawPayload.url) {
                        const name = this.getNameFromUrl(rawPayload.url);
                        return wechaty_puppet_1.FileBox.fromUrl(rawPayload.url, name);
                    }
                    else {
                        throw new Error(`can not get image/audio url fot message id: ${messageId}`);
                    }
                case wechaty_puppet_1.MessageType.Audio:
                    if (rawPayload && rawPayload.url) {
                        const name = this.getNameFromUrl(rawPayload.url);
                        const fileBox = wechaty_puppet_1.FileBox.fromUrl(rawPayload.url, name);
                        let contentXML;
                        if (pure_function_helpers_1.isRoomId(rawPayload.fromUserName)) {
                            contentXML = rawPayload.content.split(':\n')[1];
                        }
                        else {
                            contentXML = rawPayload.content;
                        }
                        const content = yield xml_to_json_1.xmlToJson(contentXML);
                        fileBox.metadata = {
                            voiceLength: content.msg.voicemsg.$.voicelength / 1000,
                        };
                        return fileBox;
                    }
                    else {
                        throw new Error(`can not get image/audio url fot message id: ${messageId}`);
                    }
                default:
                    const base64 = 'Tm90IFN1cHBvcnRlZCBBdHRhY2htZW50IEZpbGUgVHlwZSBpbiBNZXNzYWdlLgpTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9DaGF0aWUvd2VjaGF0eS9pc3N1ZXMvMTI0OQo=';
                    filename = 'wechaty-puppet-padplus-message-attachment-' + messageId + '.txt';
                    return wechaty_puppet_1.FileBox.fromBase64(base64, filename);
            }
        });
    }
    getNameFromUrl(url) {
        const _name = path_1.default.parse(url).base;
        let name = '';
        if (_name.indexOf('?')) {
            name = decodeURIComponent(_name.split('?')[0]);
        }
        else {
            name = `unknow-${Date.now()}`;
        }
        return name;
    }
    messageUrl(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageUrl(${messageId})`);
            const rawPayload = yield this.messageRawPayload(messageId);
            const payload = yield this.messagePayload(messageId);
            if (payload.type !== wechaty_puppet_1.MessageType.Url) {
                throw new Error('Can not get url from non url payload');
            }
            else {
                const appPayload = yield pure_function_helpers_1.appMessageParser(rawPayload);
                if (appPayload) {
                    return {
                        description: appPayload.des,
                        thumbnailUrl: appPayload.thumburl,
                        title: appPayload.title,
                        url: appPayload.url,
                    };
                }
                else {
                    throw new Error('Can not parse url message payload');
                }
            }
        });
    }
    messageContact(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(`not implement`);
        });
    }
    messageMiniProgram(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageMiniProgram(${messageId})`);
            const messageRawPayload = yield this.messageRawPayload(messageId);
            const miniProgramPayload = yield message_mini_program_payload_parser_1.miniProgramMessageParser(messageRawPayload);
            if (!miniProgramPayload) {
                throw new Error(`Can not abstract mini program data from the wrong xml structure.`);
            }
            return miniProgramPayload;
        });
    }
    messageForward(conversationId, messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageForward(${conversationId}, ${messageId})`);
            const payload = yield this.messagePayload(messageId);
            if (payload.type === wechaty_puppet_1.MessageType.Text) {
                if (!payload.text) {
                    throw new Error('no text');
                }
                yield this.messageSendText(conversationId, payload.text);
            }
            else if (payload.type === wechaty_puppet_1.MessageType.Audio) {
                const rawPayload = yield this.messageRawPayload(payload.id);
                let contentXML;
                let url;
                if (pure_function_helpers_1.isRoomId(rawPayload.fromUserName)) {
                    contentXML = rawPayload.content.split(':\n')[1];
                    url = rawPayload.url;
                }
                else {
                    contentXML = rawPayload.content;
                    url = rawPayload.fileName;
                }
                const content = yield xml_to_json_1.xmlToJson(contentXML);
                const voiceLength = content.msg.voicemsg.$.voicelength;
                yield this.messageSendVoice(conversationId, url, voiceLength);
            }
            else if (payload.type === wechaty_puppet_1.MessageType.Url) {
                yield this.messageSendUrl(conversationId, yield this.messageUrl(messageId));
            }
            else if (payload.type === wechaty_puppet_1.MessageType.MiniProgram) {
                yield this.messageSendMiniProgram(conversationId, yield this.messageMiniProgram(messageId));
            }
            else if (payload.type === wechaty_puppet_1.MessageType.ChatHistory) {
                throw new Error('Message type ChatHistory not supported.');
            }
            else {
                yield this.messageSendFile(conversationId, yield this.messageFile(messageId));
            }
        });
    }
    generateBaseMsg(msgId, to) {
        const msg = {
            content: '',
            createTime: new Date().getTime(),
            fromUserName: this.selfId(),
            imgStatus: 0,
            l1MsgType: 0,
            msgId,
            msgSource: '',
            msgSourceCd: 0,
            msgType: schemas_1.PadplusMessageType.Text,
            newMsgId: Number(msgId),
            pushContent: '',
            status: schemas_1.PadplusMessageStatus.One,
            toUserName: to,
            uin: '',
            wechatUserName: this.selfId(),
        };
        config_1.log.silly(PRE, 'generateBaseMsg(%s) %s', to, JSON.stringify(msg));
        this.manager.cachePadplusMessagePayload.set(msgId, msg);
        return msg;
    }
    messageSendText(conversationId, text, mentionIdList) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageSendText(${conversationId}, ${text})`);
            let msgData;
            if (mentionIdList && mentionIdList.length > 0) {
                msgData = yield this.manager.sendMessage(this.selfId(), conversationId, text, schemas_1.PadplusMessageType.Text, mentionIdList.toString());
                if (config_1.PADPLUS_REPLAY_MESSAGE) {
                    this.replayTextMsg(msgData.msgId, conversationId, text, mentionIdList);
                }
            }
            else {
                msgData = yield this.manager.sendMessage(this.selfId(), conversationId, text, schemas_1.PadplusMessageType.Text);
                if (config_1.PADPLUS_REPLAY_MESSAGE) {
                    this.replayTextMsg(msgData.msgId, conversationId, text);
                }
            }
            if (msgData.success) {
                const msgPayload = {
                    content: text,
                    createTime: msgData.timestamp,
                    fromUserName: this.selfId(),
                    imgStatus: 0,
                    l1MsgType: 0,
                    msgId: msgData.msgId,
                    msgSource: this.generateMsgSource(mentionIdList),
                    msgSourceCd: 0,
                    msgType: schemas_1.PadplusMessageType.Text,
                    newMsgId: Number(msgData.msgId),
                    pushContent: text,
                    status: 1,
                    toUserName: conversationId,
                    uin: '',
                    wechatUserName: '',
                };
                this.manager.cachePadplusMessagePayload.set(msgData.msgId, msgPayload);
            }
            return msgData.msgId;
        });
    }
    replayTextMsg(msgId, to, text, atUserList) {
        const payload = this.generateBaseMsg(msgId, to);
        payload.msgType = schemas_1.PadplusMessageType.Text;
        payload.content = text;
        if (atUserList) {
            payload.msgSource = this.generateMsgSource(atUserList);
        }
        config_1.log.silly(PRE, 'replayTextMsg replaying message: %s', JSON.stringify(payload));
        const eventMessagePayload = {
            messageId: payload.msgId,
        };
        this.emit('message', eventMessagePayload);
    }
    generateMsgSource(mentionIdList) {
        if (mentionIdList && mentionIdList.length > 0) {
            return `<msgsource>\n\t<atuserlist>${mentionIdList.join(',')}</atuserlist>\n</msgsource>\n`;
        }
        else {
            return '<msgsource>\n</msgsource>';
        }
    }
    messageSendVoice(conversationId, url, fileSize) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageSendVoice(${conversationId}, ${url}, ${fileSize})`);
            const voiceMessageData = yield this.manager.sendVoice(this.selfId(), conversationId, url, fileSize);
            if (voiceMessageData.success) {
                const msgPayload = {
                    content: url,
                    createTime: voiceMessageData.timestamp,
                    fromUserName: this.selfId(),
                    imgStatus: 0,
                    l1MsgType: 0,
                    msgId: voiceMessageData.msgId,
                    msgSource: this.generateMsgSource(),
                    msgSourceCd: 0,
                    msgType: schemas_1.PadplusMessageType.Text,
                    newMsgId: Number(voiceMessageData.msgId),
                    pushContent: url,
                    status: 1,
                    toUserName: conversationId,
                    uin: '',
                    wechatUserName: '',
                };
                this.manager.cachePadplusMessagePayload.set(voiceMessageData.msgId, msgPayload);
            }
            return voiceMessageData.msgId;
        });
    }
    messageSendContact(conversationId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageSendContact(${conversationId}, ${contactId})`);
            let contact = yield this.manager.getContact(contactId);
            if (contact) {
                const content = {
                    headImgUrl: contact.smallHeadUrl,
                    nickName: contact.nickName,
                    userName: contact.userName,
                };
                const contactData = yield this.manager.sendContact(this.selfId(), conversationId, JSON.stringify(content));
                if (config_1.PADPLUS_REPLAY_MESSAGE) {
                    this.replayContactMsg(contactData.msgId, conversationId, JSON.stringify(content));
                }
                if (contactData.success) {
                    const msgPayload = {
                        content: JSON.stringify(content),
                        createTime: contactData.timestamp,
                        fromUserName: this.selfId(),
                        imgStatus: 0,
                        l1MsgType: 0,
                        msgId: contactData.msgId,
                        msgSource: this.generateMsgSource(),
                        msgSourceCd: 0,
                        msgType: schemas_1.PadplusMessageType.Text,
                        newMsgId: Number(contactData.msgId),
                        pushContent: JSON.stringify(content),
                        status: 1,
                        toUserName: conversationId,
                        uin: '',
                        wechatUserName: '',
                    };
                    this.manager.cachePadplusMessagePayload.set(contactData.msgId, msgPayload);
                }
                return contactData.msgId;
            }
            else {
                throw new Error('not able to send contact');
            }
        });
    }
    replayContactMsg(msgId, to, content) {
        const payload = this.generateBaseMsg(msgId, to);
        payload.msgType = schemas_1.PadplusMessageType.ShareCard;
        payload.content = content;
        config_1.log.silly(PRE, 'replayContactMsg replaying message: %s', JSON.stringify(payload));
        const eventMessagePayload = {
            messageId: payload.msgId,
        };
        this.emit('message', eventMessagePayload);
    }
    messageSendFile(conversationId, file) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageSendFile(${conversationId})`);
            let fileUrl = '';
            if (file.remoteUrl) {
                fileUrl = file.remoteUrl;
            }
            else {
                fileUrl = yield this.manager.generatorFileUrl(file);
            }
            const fileSize = (yield file.toBuffer()).length;
            config_1.log.silly(PRE, `file url : ${fileUrl}`);
            const type = (file.mimeType && file.mimeType !== 'application/octet-stream')
                ? file.mimeType
                : path_1.default.extname(file.name);
            config_1.log.silly(PRE, `fileType ${type}`);
            switch (type) {
                case '.slk':
                    throw new Error('not support');
                case 'image/jpeg':
                case 'image/png':
                case '.jpg':
                case '.jpeg':
                case '.png':
                    const picData = yield this.manager.sendFile(this.selfId(), conversationId, fileUrl, file.name, 'pic');
                    if (config_1.PADPLUS_REPLAY_MESSAGE) {
                        this.replayImageMsg(picData.msgId, conversationId, fileUrl);
                    }
                    if (picData.success) {
                        const msgPayload = {
                            content: `<msg>${fileUrl}</msg>`,
                            createTime: picData.timestamp,
                            fromUserName: this.selfId(),
                            imgStatus: 0,
                            l1MsgType: 0,
                            msgId: picData.msgId,
                            msgSource: this.generateMsgSource(),
                            msgSourceCd: 0,
                            msgType: schemas_1.PadplusMessageType.Text,
                            newMsgId: Number(picData.msgId),
                            pushContent: `<msg>${fileUrl}</msg>`,
                            status: 1,
                            toUserName: conversationId,
                            uin: '',
                            wechatUserName: '',
                        };
                        this.manager.cachePadplusMessagePayload.set(picData.msgId, msgPayload);
                    }
                    return picData.msgId;
                case 'video/mp4':
                case '.mp4':
                    const videoData = yield this.manager.sendVideo(this.selfId(), conversationId, fileUrl);
                    if (config_1.PADPLUS_REPLAY_MESSAGE) {
                        this.replayAppMsg(videoData.msgId, conversationId, fileUrl);
                    }
                    if (videoData.success) {
                        const msgPayload = {
                            content: `<msg>${fileUrl}</msg>`,
                            createTime: videoData.timestamp,
                            fromUserName: this.selfId(),
                            imgStatus: 0,
                            l1MsgType: 0,
                            msgId: videoData.msgId,
                            msgSource: this.generateMsgSource(),
                            msgSourceCd: 0,
                            msgType: schemas_1.PadplusMessageType.Text,
                            newMsgId: Number(videoData.msgId),
                            pushContent: `<msg>${fileUrl}</msg>`,
                            status: 1,
                            toUserName: conversationId,
                            uin: '',
                            wechatUserName: '',
                        };
                        this.manager.cachePadplusMessagePayload.set(videoData.msgId, msgPayload);
                    }
                    return videoData.msgId;
                case 'application/xml':
                    throw new Error(`Can not parse the url data, please input a name for FileBox.fromUrl(url, name).`);
                default:
                    const docData = yield this.manager.sendFile(this.selfId(), conversationId, fileUrl, file.name, 'doc', fileSize);
                    if (config_1.PADPLUS_REPLAY_MESSAGE) {
                        this.replayAppMsg(docData.msgId, conversationId, fileUrl);
                    }
                    if (docData.success) {
                        const msgPayload = {
                            content: `<msg>${fileUrl}</msg>`,
                            createTime: docData.timestamp,
                            fromUserName: this.selfId(),
                            imgStatus: 0,
                            l1MsgType: 0,
                            msgId: docData.msgId,
                            msgSource: this.generateMsgSource(),
                            msgSourceCd: 0,
                            msgType: schemas_1.PadplusMessageType.Text,
                            newMsgId: Number(docData.msgId),
                            pushContent: `<msg>${fileUrl}</msg>`,
                            status: 1,
                            toUserName: conversationId,
                            uin: '',
                            wechatUserName: '',
                        };
                        this.manager.cachePadplusMessagePayload.set(docData.msgId, msgPayload);
                    }
                    return docData.msgId;
            }
        });
    }
    replayImageMsg(msgId, to, url) {
        const payload = this.generateBaseMsg(msgId, to);
        payload.msgType = schemas_1.PadplusMessageType.Image;
        payload.content = `<msg>${url}</msg>`;
        payload.url = url;
        config_1.log.silly(PRE, 'replayImageMsg replaying message: %s', JSON.stringify(payload));
        const eventMessagePayload = {
            messageId: payload.msgId,
        };
        this.emit('message', eventMessagePayload);
    }
    replayAppMsg(msgId, to, content) {
        const payload = this.generateBaseMsg(msgId, to);
        payload.msgType = schemas_1.PadplusMessageType.App;
        payload.content = `<msg>${content}</msg>`;
        config_1.log.silly(PRE, 'replayAppMsg replaying message: %s', JSON.stringify(payload));
        const eventMessagePayload = {
            messageId: payload.msgId,
        };
        this.emit('message', eventMessagePayload);
    }
    messageSendUrl(conversationId, urlLinkPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageSendUrl(${conversationId})`);
            const { url, title, thumbnailUrl, description } = urlLinkPayload;
            const payload = {
                description,
                thumburl: thumbnailUrl,
                title,
                type: 5,
                url,
            };
            const urlLinkData = yield this.manager.sendUrlLink(this.selfId(), conversationId, JSON.stringify(payload));
            if (config_1.PADPLUS_REPLAY_MESSAGE) {
                this.replayUrlLinkMsg(urlLinkData.msgId, conversationId, JSON.stringify(payload));
            }
            if (urlLinkData.success) {
                const msgPayload = {
                    content: JSON.stringify(payload),
                    createTime: urlLinkData.timestamp,
                    fromUserName: this.selfId(),
                    imgStatus: 0,
                    l1MsgType: 0,
                    msgId: urlLinkData.msgId,
                    msgSource: this.generateMsgSource(),
                    msgSourceCd: 0,
                    msgType: schemas_1.PadplusMessageType.Text,
                    newMsgId: Number(urlLinkData.msgId),
                    pushContent: JSON.stringify(payload),
                    status: 1,
                    toUserName: conversationId,
                    uin: '',
                    wechatUserName: '',
                };
                this.manager.cachePadplusMessagePayload.set(urlLinkData.msgId, msgPayload);
            }
            return urlLinkData.msgId;
        });
    }
    replayUrlLinkMsg(msgId, to, content) {
        const payload = this.generateBaseMsg(msgId, to);
        payload.msgType = schemas_1.PadplusMessageType.App;
        payload.content = content;
        config_1.log.silly(PRE, 'replayUrlLinkMsg replaying message: %s', JSON.stringify(payload));
        const eventMessagePayload = {
            messageId: payload.msgId,
        };
        this.emit('message', eventMessagePayload);
    }
    messageSendMiniProgram(conversationId, miniProgramPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageSendMiniProgram(${conversationId}, ${miniProgramPayload})`);
            if (!this.manager) {
                throw new Error(`no manager`);
            }
            const content = message_convertor_1.convertMiniProgramPayloadToParams(miniProgramPayload);
            const miniProgramData = yield this.manager.sendMiniProgram(this.selfId(), conversationId, JSON.stringify(content));
            if (config_1.PADPLUS_REPLAY_MESSAGE) {
                this.replayUrlLinkMsg(miniProgramData.msgId, conversationId, JSON.stringify(content));
            }
            if (miniProgramData.success) {
                const source = this.generateMsgSource();
                const msgPayload = message_convertor_1.convertMiniProgramPayloadToMessage(this.selfId(), conversationId, source, content, miniProgramData);
                this.manager.cachePadplusMessagePayload.set(miniProgramData.msgId, msgPayload);
            }
            return miniProgramData.msgId;
        });
    }
    messageRawPayload(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageRawPayload(${messageId})`);
            if (!this.manager) {
                throw new Error(`no manager`);
            }
            let rawPayload = this.manager.cachePadplusMessagePayload.get(messageId);
            if (rawPayload) {
                return rawPayload;
            }
            if (!this.manager.cacheManager) {
                throw new Error(`no cache manager`);
            }
            rawPayload = yield this.manager.cacheManager.getMessage(messageId);
            if (!rawPayload) {
                config_1.log.error('PuppetPadplus', 'messageRawPayload(%s) manager.cacheManager.getMessage(%s) return nothing.', messageId, messageId);
                throw new Error('no message rawPayload for message id ' + messageId);
            }
            return rawPayload;
        });
    }
    messageRawPayloadParser(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, 'messageRawPayloadParser()');
            const payload = yield pure_function_helpers_1.messageRawPayloadParser(rawPayload);
            if (payload.mentionIdList && payload.mentionIdList.length === 1 && payload.mentionIdList[0] === 'announcement@all') {
                const memberIds = yield this.roomMemberList(payload.roomId);
                payload.mentionIdList = memberIds.filter(m => m !== payload.fromId);
                payload.text = `${payload.text || ''}`;
            }
            return payload;
        });
    }
    messageRecall(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `messageRecall(${messageId})`);
            const payload = yield this.messagePayload(messageId);
            const receiverId = payload.roomId || payload.toId;
            config_1.log.silly(PRE, 'messageRecall(%s, %s)', receiverId, messageId);
            const isSuccess = yield this.manager.recallMessage(this.selfId(), receiverId, messageId);
            return isSuccess;
        });
    }
    /**
     * ========================
     *      ROOM SECTION
     * ========================
     */
    onRoomJoinEvent(message) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `onRoomJoinEvent(${message.msgId})`);
            const joinEvent = yield room_event_join_message_parser_1.roomJoinEventMessageParser(message);
            if (joinEvent) {
                config_1.log.silly(PRE, `receive room-join event : ${util_1.default.inspect(joinEvent)}`);
                const inviteeNameList = joinEvent.inviteeNameList;
                const inviterName = joinEvent.inviterName;
                const roomId = joinEvent.roomId;
                const timestamp = joinEvent.timestamp;
                const inviteeIdList = yield config_1.retry((retryException, attempt) => __awaiter(this, void 0, void 0, function* () {
                    config_1.log.silly(PRE, 'onPadplusMessageRoomEventJoin({id=%s}) roomJoin retry(attempt=%d)', attempt);
                    const tryIdList = array_flatten_1.flatten(yield Promise.all(inviteeNameList.map(inviteeName => this.roomMemberSearch(roomId, inviteeName))));
                    if (tryIdList.length) {
                        return tryIdList;
                    }
                    if (!this.manager) {
                        throw new Error('no manager');
                    }
                    // Set Cache Dirty
                    yield this.roomMemberPayloadDirty(roomId);
                    return retryException(new Error('roomMemberSearch() not found'));
                })).catch(e => {
                    config_1.log.silly(PRE, 'onPadplusMessageRoomEventJoin({id=%s}) roomJoin retry() fail: %s', e.message);
                    return [];
                });
                let inviterIdList = yield this.roomMemberSearch(roomId, inviterName);
                if (inviterIdList.length < 1) {
                    yield this.roomMemberPayloadDirty(roomId);
                    yield this.manager.getRoomMembers(roomId);
                    inviterIdList = yield this.roomMemberSearch(roomId, inviterName);
                    if (inviterIdList.length < 1) {
                        throw new Error(`can not get room member`);
                    }
                }
                else if (inviterIdList.length > 1) {
                    config_1.log.silly(PRE, 'onPadplusMessageRoomEventJoin() inviterId found more than 1, use the first one.');
                }
                const inviterId = inviterIdList[0];
                // Set Cache Dirty
                yield this.roomMemberPayloadDirty(roomId);
                yield this.roomPayloadDirty(roomId);
                const eventRoomJoinPayload = {
                    inviteeIdList,
                    inviterId,
                    roomId,
                    timestamp,
                };
                this.emit('room-join', eventRoomJoinPayload);
            }
        });
    }
    onRoomLeaveEvent(message) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `onRoomLeaveEvent(${message.msgId})`);
            const leaveEvent = room_event_leave_message_parser_1.roomLeaveEventMessageParser(message);
            if (leaveEvent) {
                config_1.log.silly(PRE, `receive room-leave event : ${util_1.default.inspect(leaveEvent)}`);
                const leaverNameList = leaveEvent.leaverNameList;
                const removerName = leaveEvent.removerName;
                const roomId = leaveEvent.roomId;
                const timestamp = leaveEvent.timestamp;
                const leaverIdList = array_flatten_1.flatten(yield Promise.all(leaverNameList.map(leaverName => this.roomMemberSearch(roomId, leaverName))));
                const removerIdList = yield this.roomMemberSearch(roomId, removerName);
                if (removerIdList.length < 1) {
                    throw new Error('no removerId found');
                }
                else if (removerIdList.length > 1) {
                    config_1.log.silly(PRE, 'onPadplusMessageRoomEventLeave(): removerId found more than 1, use the first one.');
                }
                const removerId = removerIdList[0];
                if (!this.manager) {
                    throw new Error('no padplusManager');
                }
                const eventRoomLeavePayload = {
                    removeeIdList: leaverIdList,
                    removerId,
                    roomId,
                    timestamp,
                };
                this.deduplicateRoomLeaveEvent(eventRoomLeavePayload);
            }
        });
    }
    onRoomTopicEvent(message) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `onRoomTopicEvent(${message.msgId})`);
            const topicEvent = room_event_topic_message_parser_1.roomTopicEventMessageParser(message);
            if (topicEvent) {
                config_1.log.silly(PRE, `receive room-topic event : ${util_1.default.inspect(topicEvent)}`);
                const changerName = topicEvent.changerName;
                const newTopic = topicEvent.topic;
                const roomId = topicEvent.roomId;
                const timestamp = topicEvent.timestamp;
                const roomOldPayload = yield this.roomPayload(roomId);
                const oldTopic = roomOldPayload.topic;
                const changerIdList = yield this.roomMemberSearch(roomId, changerName);
                if (changerIdList.length < 1) {
                    throw new Error('no changerId found');
                }
                else if (changerIdList.length > 1) {
                    config_1.log.silly(PRE, 'onPadplusMessageRoomEventTopic() changerId found more than 1, use the first one.');
                }
                const changerId = changerIdList[0];
                if (!this.manager) {
                    throw new Error('no padplusManager');
                }
                // Set Cache Dirty
                yield this.roomPayloadDirty(roomId);
                if (this.manager && this.manager.cacheManager) {
                    yield this.manager.cacheManager.deleteRoom(roomId);
                }
                const eventRoomTopicPayload = {
                    changerId,
                    newTopic,
                    oldTopic,
                    roomId,
                    timestamp,
                };
                this.emit('room-topic', eventRoomTopicPayload);
            }
        });
    }
    onRoomInvitation(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, 'onRoomInvitation()');
            const roomInviteEvent = yield pure_function_helpers_1.roomInviteEventMessageParser(rawPayload);
            if (roomInviteEvent) {
                if (!this.manager) {
                    throw new Error('no manager');
                }
                yield this.manager.saveRoomInvitationRawPayload(roomInviteEvent);
                const eventRoomInvitePayload = {
                    roomInvitationId: roomInviteEvent.msgId,
                };
                this.emit('room-invite', eventRoomInvitePayload);
            }
            else {
                const eventMessagePayload = {
                    messageId: rawPayload.msgId,
                };
                this.emit('message', eventMessagePayload);
            }
        });
    }
    roomInvitationAccept(roomInvitationId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomInvitationAccept(${roomInvitationId})`);
            if (!this.manager) {
                throw new Error('no manager');
            }
            yield this.manager.roomInvitationAccept(roomInvitationId);
        });
    }
    roomInvitationRawPayload(roomInvitationId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomInvitationRawPayload(${roomInvitationId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const payload = yield this.manager.roomInvitationRawPayload(roomInvitationId);
            return payload;
        });
    }
    roomInvitationRawPayloadParser(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomInvitationRawPayloadParser()`);
            const payload = {
                avatar: rawPayload.thumbUrl,
                id: rawPayload.id,
                invitation: rawPayload.url,
                inviterId: rawPayload.fromUser,
                memberCount: 0,
                memberIdList: [],
                receiverId: rawPayload.receiver,
                timestamp: rawPayload.timestamp,
                topic: rawPayload.roomName,
            };
            return payload;
        });
    }
    roomAvatar(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomAvatar(${roomId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const room = yield this.roomRawPayload(roomId);
            if (room) {
                const avatarUrl = room.bigHeadUrl || room.smallHeadUrl;
                return wechaty_puppet_1.FileBox.fromUrl(avatarUrl, `${roomId}_avatar_${Date.now()}.png`);
            }
            else {
                throw new Error(`Can not load room info by roomId : ${roomId}`);
            }
        });
    }
    roomCreate(contactIdList, topic) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomCreate(${contactIdList}, ${topic})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const result = yield this.manager.createRoom(topic || '', contactIdList);
            return result;
        });
    }
    roomAdd(roomId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomAdd(${roomId}, ${contactId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            yield this.manager.roomAddMember(roomId, contactId);
        });
    }
    roomDel(roomId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomDel(${roomId}, ${contactId})`);
            const memberIdList = yield this.roomMemberList(roomId);
            if (memberIdList.includes(contactId)) {
                yield this.manager.deleteRoomMember(roomId, contactId);
            }
            else {
                config_1.log.silly(PRE, `roomDel() room(${roomId}) has no member contact(${contactId})`);
            }
        });
    }
    roomQuit(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomQuit(${roomId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            yield this.manager.quitRoom(roomId);
        });
    }
    roomTopic(roomId, topic) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomTopic(${roomId}, ${topic})`);
            if (typeof topic === 'undefined') {
                const room = yield this.roomPayload(roomId);
                return room && (room.topic || '');
            }
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            yield this.manager.setRoomTopic(roomId, topic);
            yield this.roomPayloadDirty(roomId);
            yield new Promise(resolve => setTimeout(resolve, 500));
            yield this.roomTopic(roomId);
        });
    }
    roomQRCode(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomQRCode(${roomId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            return this.manager.getRoomQrcode(roomId);
        });
    }
    roomList() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomList()`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            return this.manager.getRoomIdList();
        });
    }
    roomMemberList(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomMemberList(${roomId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const roomIds = yield this.manager.getRoomMemberIdList(roomId);
            return roomIds;
        });
    }
    roomRawPayload(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomRawPayload(${roomId})`);
            const rawRoom = yield this.manager.getRoomInfo(roomId);
            return rawRoom;
        });
    }
    roomRawPayloadParser(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomRawPayloadParser()`);
            const room = pure_function_helpers_1.roomRawPayloadParser(rawPayload);
            return room;
        });
    }
    roomMemberRawPayload(roomId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomMemberRawPayload(${roomId}, ${contactId})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            const memberMap = yield this.manager.getRoomMembers(roomId);
            if (!memberMap) {
                throw new Error('can not find members. may be you are removed.');
            }
            const member = memberMap[contactId];
            return member;
        });
    }
    roomMemberRawPayloadParser(rawPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomMemberRawPayloadParser()`);
            const member = room_convertor_1.convertToPuppetRoomMember(rawPayload);
            return member;
        });
    }
    roomAnnounce(roomId, text) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `roomAnnounce(${roomId}, ${typeof text === 'undefined' ? 'text is undefined' : text})`);
            if (!this.manager) {
                throw new Error(`no manager.`);
            }
            if (typeof text === 'undefined') {
                return this.manager.getAnnouncement(roomId);
            }
            else {
                return this.manager.setAnnouncement(roomId, text);
            }
        });
    }
    /**
     * External method
     */
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `reconnect()`);
            if (!this.manager) {
                throw new Error('no manager');
            }
            yield this.manager.reconnect();
        });
    }
    loginDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly(PRE, `loginDevice()`);
            if (!this.manager) {
                throw new Error('no manager');
            }
            return this.manager.loginDevice();
        });
    }
    ding(data) {
        config_1.log.silly(PRE, `ding(${data})`);
        const eventDongPayload = {
            data: data ? data : 'ding-dong',
        };
        this.emit('dong', eventDongPayload);
    }
    deduplicateRoomLeaveEvent(data) {
        const key = `${data.removeeIdList[0]}_${data.roomId}`;
        if (data.removerId !== data.removeeIdList[0]) {
            this.leaveEventKey = key;
            this.emit('room-leave', data);
        }
        else {
            if (this.leaveEventKey && this.leaveEventKey === key) {
                this.leaveEventKey = '';
            }
            else {
                this.emit('room-leave', data);
            }
        }
    }
}
exports.PuppetPadplus = PuppetPadplus;
exports.default = PuppetPadplus;
//# sourceMappingURL=puppet-padplus.js.map