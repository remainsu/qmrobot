"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("../../config");
const PadPlusServer_pb_1 = require("../../server-manager/proto-ts/PadPlusServer_pb");
const contact_convertor_1 = require("../../convert-manager/contact-convertor");
const PRE = 'PadplusContact';
class PadplusContact {
    constructor(requestClient) {
        // Query contact list info
        this.getContactInfo = (userName) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `getContactInfo(${userName})`);
            const data = {
                userName,
            };
            yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.GET_CONTACT,
                data,
            });
            return true;
        });
        this.searchContact = (contactId) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `searchContact(${contactId})`);
            const data = {
                wxid: contactId,
            };
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.SEARCH_CONTACT,
                data,
            });
            if (result) {
                const contactStr = result.getData();
                if (contactStr) {
                    return JSON.parse(contactStr);
                }
                else {
                    throw new Error(`searchContact can not parse data`);
                }
            }
            else {
                throw new Error(`can not get callback result of SEARCH_CONTACT`);
            }
        });
        // Set alias for contact
        this.setAlias = (contactId, alias) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `setAlias()`);
            const data = {
                newRemarkName: alias,
                userName: contactId,
            };
            yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.CONTACT_ALIAS,
                data,
            });
            return true;
        });
        this.syncContacts = () => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `syncContacts()`);
            yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.SYNC_CONTACT,
            });
        });
        this.contactSelfQrcode = () => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `contactSelfQrcode()`);
            const data = {
                style: 0,
                type: 1,
            };
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.GET_CONTACT_SELF_QRCODE,
                data,
            });
            if (result) {
                const contactQrcodeStr = result.getData();
                if (contactQrcodeStr) {
                    const contactQrcode = JSON.parse(contactQrcodeStr);
                    if (contactQrcode.status === 0) {
                        return contactQrcode.qrcodeBuf;
                    }
                    else {
                        throw new Error(`Can not get contact self qrcode buffer.`);
                    }
                }
                else {
                    throw new Error(`contactSelfQrcode can not parse data`);
                }
            }
            else {
                throw new Error(`can not get callback result of GET_CONTACT_SELF_QRCODE`);
            }
        });
        this.setContactSelfInfo = (data) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `setContactSelfInfo()`);
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.SET_CONTACT_SELF_INFO,
                data,
            });
            if (result) {
                const setContactSelfInfoStr = result.getData();
                if (setContactSelfInfoStr) {
                    const setContactSelfInfoGrpcResponse = JSON.parse(setContactSelfInfoStr);
                    if (setContactSelfInfoGrpcResponse.status !== 0) {
                        throw new Error(`Can not set contact self ${Object.keys(data).join(',')}.`);
                    }
                    else {
                        config_1.log.silly(PRE, `update info : ${JSON.stringify(setContactSelfInfoGrpcResponse.updateData)}`);
                    }
                }
                else {
                    throw new Error(`setContactSelfInfo can not parse data`);
                }
            }
            else {
                throw new Error(`can not get callback result of SET_CONTACT_SELF_INFO`);
            }
        });
        this.getContactSelfInfo = () => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `getContactSelfInfo()`);
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.GET_CONTACT_SELF_INFO,
            });
            if (result) {
                const getContactSelfInfoStr = result.getData();
                if (getContactSelfInfoStr) {
                    const getContactSelfInfoGrpcResponse = JSON.parse(getContactSelfInfoStr);
                    if (getContactSelfInfoGrpcResponse.status !== 0) {
                        throw new Error(`Can not get contact self info.`);
                    }
                    else {
                        return getContactSelfInfoGrpcResponse;
                    }
                }
                else {
                    throw new Error(`getContactSelfInfo can not parse data`);
                }
            }
            else {
                throw new Error(`can not get callback result of GET_CONTACT_SELF_INFO`);
            }
        });
        this.requestClient = requestClient;
    }
    getOrCreateTag(tag) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `getOrCreateTag(${tag})`);
            const data = {
                name: tag,
            };
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.CREATE_TAG,
                data,
            });
            if (result) {
                const tagGrpcResponseStr = result.getData();
                if (tagGrpcResponseStr) {
                    const tagListGrpcResponse = contact_convertor_1.convertTagStr(tagGrpcResponseStr);
                    let tagIDs = '';
                    if (tagListGrpcResponse.tagList && tagListGrpcResponse.tagList.length > 0) {
                        yield Promise.all(tagListGrpcResponse.tagList.map((tagItem, index) => {
                            if (index === tagListGrpcResponse.tagList.length - 1) {
                                tagIDs += tagItem.LabelID;
                            }
                            else {
                                tagIDs += tagItem.LabelID + ',';
                            }
                        }));
                    }
                    return tagIDs;
                }
                else {
                    throw new Error(`getOrCreateTag can not parse data`);
                }
            }
            else {
                throw new Error(`getOrCreateTag can not get callback result`);
            }
        });
    }
    tagList() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `tagList()`);
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.GET_ALL_TAG,
            });
            if (result) {
                const tagGrpcResponseStr = result.getData();
                if (tagGrpcResponseStr) {
                    const tagListGrpcResponse = contact_convertor_1.convertTagStr(tagGrpcResponseStr);
                    return tagListGrpcResponse.tagList;
                }
                else {
                    throw new Error(`tagList can not parse data`);
                }
            }
            else {
                throw new Error(`tagList can not get callback result`);
            }
        });
    }
    addTag(tagId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `addTag(${tagId})`);
            const data = {
                labelIds: tagId,
                userName: contactId,
            };
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.ADD_TAG,
                data,
            });
            if (result) {
                const tagOperationsGrpcResponseStr = result.getData();
                if (tagOperationsGrpcResponseStr) {
                    const tagOperationsGrpcResponse = JSON.parse(tagOperationsGrpcResponseStr);
                    if (tagOperationsGrpcResponse.status !== 0) {
                        throw new Error(`Add operation failed!`);
                    }
                }
                else {
                    throw new Error(`addTag can not parse data`);
                }
            }
            else {
                throw new Error(`addTag can not get callback result`);
            }
        });
    }
    modifyTag(tagId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `modifyTag(${tagId}, ${name})`);
            const data = {
                labelId: tagId,
                labelName: name,
            };
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.MODIFY_TAG,
                data,
            });
            if (result) {
                const tagOperationsGrpcResponseStr = result.getData();
                if (tagOperationsGrpcResponseStr) {
                    const tagOperationsGrpcResponse = JSON.parse(tagOperationsGrpcResponseStr);
                    if (tagOperationsGrpcResponse.status !== 0) {
                        throw new Error(`Modify operation failed!`);
                    }
                }
                else {
                    throw new Error(`modifyTag can not parse data`);
                }
            }
            else {
                throw new Error(`modifyTag can not get callback result`);
            }
        });
    }
    deleteTag(tagId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose(PRE, `deleteTag(${tagId})`);
            const data = {
                labelIds: tagId,
            };
            const result = yield this.requestClient.request({
                apiType: PadPlusServer_pb_1.ApiType.DELETE_TAG,
                data,
            });
            if (result) {
                const tagOperationsGrpcResponseStr = result.getData();
                if (tagOperationsGrpcResponseStr) {
                    const tagOperationsGrpcResponse = JSON.parse(tagOperationsGrpcResponseStr);
                    if (tagOperationsGrpcResponse.status !== 0) {
                        throw new Error(`Delete operation failed!`);
                    }
                }
                else {
                    throw new Error(`deleteTag can not parse data`);
                }
            }
            else {
                throw new Error(`deleteTag can not get callback result`);
            }
        });
    }
}
exports.PadplusContact = PadplusContact;
//# sourceMappingURL=contact.js.map