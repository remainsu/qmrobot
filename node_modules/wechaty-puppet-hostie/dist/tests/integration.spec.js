#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const src_1 = require("../src/");
const wechaty_puppet_mock_1 = require("wechaty-puppet-mock");
tstest_1.test('integration testing', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const TOKEN = 'test_token';
    const ENDPOINT = '0.0.0.0:8788';
    const DING = 'ding_data';
    /**
     * Puppet in Hostie
     */
    const puppet = new wechaty_puppet_mock_1.PuppetMock();
    const spyStart = tstest_1.sinon.spy(puppet, 'start');
    const spyOn = tstest_1.sinon.spy(puppet, 'on');
    const spyDing = tstest_1.sinon.spy(puppet, 'ding');
    /**
     * Hostie Server
     */
    const serverOptions = {
        endpoint: ENDPOINT,
        puppet: puppet,
        token: TOKEN,
    };
    const hostieServer = new src_1.PuppetServer(serverOptions);
    yield hostieServer.start();
    /**
     * Puppet Hostie Client
     */
    const puppetOptions = {
        endpoint: ENDPOINT,
        token: TOKEN,
    };
    const puppetHostie = new src_1.PuppetHostie(puppetOptions);
    yield puppetHostie.start();
    t.ok(spyStart.called, 'should called the hostie server start() function');
    const future = new Promise((resolve, reject) => {
        puppetHostie.on('dong', resolve);
        puppetHostie.on('error', reject);
    });
    puppetHostie.ding(DING);
    const result = yield future;
    t.ok(spyOn.called, 'should called the hostie server on() function');
    t.ok(spyDing.called, 'should called the hostie server ding() function');
    t.equal(result, DING, 'should get a successful roundtrip for ding');
    /**
     * Stop
     *  1. Puppet in Hostie
     *  2. Hostie Service
     *  3. Puppet Hostie Client
     *
     */
    yield puppetHostie.stop();
    yield hostieServer.stop();
}));
//# sourceMappingURL=integration.spec.js.map