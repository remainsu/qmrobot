"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __importDefault(require("util"));
const grpc_1 = __importDefault(require("grpc"));
const ws_1 = __importDefault(require("ws"));
// import { DebounceQueue } from 'rx-queue'
const wechaty_puppet_1 = require("wechaty-puppet");
const grpc_2 = require("@chatie/grpc");
const config_1 = require("../config");
const event_type_rev_1 = require("../event-type-rev");
const recover_1 = require("./recover$");
class PuppetHostie extends wechaty_puppet_1.Puppet {
    // protected recoverSubscription: Subscription
    constructor(options = {}) {
        super(options);
        this.options = options;
        options.endpoint = options.endpoint || config_1.WECHATY_PUPPET_HOSTIE_ENDPOINT;
        options.token = options.token || config_1.WECHATY_PUPPET_HOSTIE_TOKEN;
        if (!options.token) {
            throw new Error('wechaty-puppet-hostie: token not found. See: <https://github.com/wechaty/wechaty-puppet-hostie#1-wechaty_puppet_hostie_token>');
        }
        // this.heartbeatDebounceQueue = new DebounceQueue(HEARTBEAT_DEBOUNCE_TIME * 1000)
        this.cleanCallbackList = [];
        // this.recoverSubscription =
        recover_1.recover$(this).subscribe(x => config_1.log.verbose('PuppetHostie', 'constructor() recover$().subscribe() next(%s)', JSON.stringify(x)), e => config_1.log.error('PuppetHostie', 'constructor() recover$().subscribe() error(%s)', e), () => config_1.log.verbose('PuppetHostie', 'constructor() recover$().subscribe() complete()'));
    }
    discoverHostieIp(token) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', `discoverHostieIp(%s)`, token);
            // let DEBUG = true as boolean
            // if (DEBUG) {
            //   return '127.0.0.1'
            // }
            const CHATIE_ENDPOINT = 'wss://api.chatie.io/v0/websocket/token/';
            const PROTOCOL = 'puppet-hostie|0.0.1';
            const ws = new ws_1.default(CHATIE_ENDPOINT + token, PROTOCOL);
            try {
                return yield new Promise((resolve, reject) => {
                    ws.once('open', function open() {
                        ws.send(JSON.stringify({
                            name: 'hostie',
                        }));
                    });
                    ws.on('message', function incoming(data) {
                        const event = JSON.parse(data);
                        if (event.name === 'hostie') {
                            config_1.log.verbose('PuppetHostie', `discoverHostieIp() %s`, event.payload);
                            return resolve(event.payload);
                        }
                        else {
                            // console.info('other:', event)
                        }
                    });
                    ws.once('error', reject);
                    ws.once('close', reject);
                });
            }
            finally {
                ws.close();
            }
        });
    }
    startGrpcClient() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', `startGrpcClient()`);
            if (this.grpcClient) {
                throw new Error('puppetClient had already inited');
            }
            let endpoint = this.options.endpoint;
            if (!endpoint) {
                const ip = yield this.discoverHostieIp(this.options.token);
                if (!ip || ip === '0.0.0.0') {
                    throw new Error('no endpoint');
                }
                endpoint = ip + ':8788';
            }
            this.grpcClient = new grpc_2.PuppetClient(endpoint, // 'localhost:50051',
            grpc_1.default.credentials.createInsecure());
        });
    }
    stopGrpcClient() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', `stopGrpcClient()`);
            if (!this.grpcClient) {
                throw new Error('puppetClient had not inited');
            }
            this.grpcClient.close();
            this.grpcClient = undefined;
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', `start()`);
            if (this.state.on()) {
                config_1.log.warn('PuppetHostie', 'start() is called on a ON puppet. await ready(on) and return.');
                yield this.state.ready('on');
                return;
            }
            this.state.on('pending');
            try {
                yield this.startGrpcClient();
                if (!this.grpcClient) {
                    throw new Error('no grpc client');
                }
                this.startGrpcStream();
                // this.startDing()
                yield util_1.default.promisify(this.grpcClient.start
                    .bind(this.grpcClient))(new grpc_2.StartRequest());
                this.state.on(true);
            }
            catch (e) {
                config_1.log.error('PuppetHostie', 'start() rejection: %s', e && e.message);
                this.state.off(true);
                throw e;
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'stop()');
            if (this.state.off()) {
                config_1.log.warn('PuppetHostie', 'stop() is called on a OFF puppet. await ready(off) and return.');
                yield this.state.ready('off');
                return;
            }
            try {
                this.state.off('pending');
                this.cleanCallbackList.forEach(cb => cb());
                this.cleanCallbackList = [];
                if (this.logonoff()) {
                    this.emit('logout', {
                        contactId: this.selfId(),
                        data: 'PuppetHostie stop()',
                    });
                    this.id = undefined;
                }
                this.stopGrpcStream();
                if (this.grpcClient) {
                    try {
                        yield util_1.default.promisify(this.grpcClient.stop
                            .bind(this.grpcClient))(new grpc_2.StopRequest());
                    }
                    catch (e) {
                        config_1.log.error('PuppetHostie', 'stop() this.grpcClient.stop() rejection: %s', e.message);
                    }
                }
                else {
                    config_1.log.warn('PuppetHostie', 'stop() this.grpcClient not exist');
                }
                yield this.stopGrpcClient();
            }
            catch (e) {
                config_1.log.warn('PuppetHostie', 'stop() rejection: %s', e && e.message);
                // throw e
            }
            finally {
                this.state.off(true);
            }
        });
    }
    startGrpcStream() {
        config_1.log.verbose('PuppetHostie', 'startGrpcStream()');
        if (this.eventStream) {
            throw new Error('event stream exists');
        }
        this.eventStream = this.grpcClient.event(new grpc_2.EventRequest());
        this.eventStream
            .on('data', this.onGrpcStreamEvent.bind(this))
            .on('end', () => {
            config_1.log.verbose('PuppetHostie', 'startGrpcStream() eventStream.on(end)');
        })
            .on('error', e => {
            // https://github.com/wechaty/wechaty-puppet-hostie/issues/16
            config_1.log.verbose('PuppetHostie', 'startGrpcStream() eventStream.on(error) %s', e);
            const reason = 'startGrpcStream() eventStream.on(error) ' + e;
            /**
             * The `Puppet` class have a throttleQueue for receiving the `reset` events
             *  and it's the `Puppet` class's duty for call the `puppet.reset()` to reset the puppet.
             */
            this.emit('reset', { data: reason });
        })
            .on('cancel', (...args) => {
            config_1.log.verbose('PuppetHostie', 'startGrpcStream() eventStream.on(cancel), %s', JSON.stringify(args));
        });
    }
    onGrpcStreamEvent(event) {
        const type = event.getType();
        const payload = event.getPayload();
        config_1.log.verbose('PuppetHostie', 'onGrpcStreamEvent({type:%s(%s), payload:"%s"})', event_type_rev_1.EventTypeRev[type], type, payload);
        if (type !== grpc_2.EventType.EVENT_TYPE_HEARTBEAT) {
            this.emit('heartbeat', {
                data: `onGrpcStreamEvent(${event_type_rev_1.EventTypeRev[type]})`,
            });
        }
        switch (type) {
            case grpc_2.EventType.EVENT_TYPE_DONG:
                this.emit('dong', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_ERROR:
                this.emit('error', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_HEARTBEAT:
                this.emit('heartbeat', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_FRIENDSHIP:
                this.emit('friendship', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_LOGIN:
                const loginPayload = JSON.parse(payload);
                this.id = loginPayload.contactId;
                this.emit('login', loginPayload);
                break;
            case grpc_2.EventType.EVENT_TYPE_LOGOUT:
                this.id = undefined;
                this.emit('logout', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_MESSAGE:
                this.emit('message', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_READY:
                this.emit('ready', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_ROOM_INVITE:
                this.emit('room-invite', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_ROOM_JOIN:
                this.emit('room-join', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_ROOM_LEAVE:
                this.emit('room-leave', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_ROOM_TOPIC:
                this.emit('room-topic', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_SCAN:
                this.emit('scan', JSON.parse(payload));
                break;
            case grpc_2.EventType.EVENT_TYPE_RESET:
                config_1.log.warn('PuppetHostie', 'onGrpcStreamEvent() got an EventType.EVENT_TYPE_RESET ?');
                // the `reset` event should be dealed not send out
                break;
            case grpc_2.EventType.EVENT_TYPE_UNSPECIFIED:
                config_1.log.error('PuppetHostie', 'onGrpcStreamEvent() got an EventType.EVENT_TYPE_UNSPECIFIED ?');
                break;
            default:
                // Huan(202003): in default, the `type` type should be `never`, please check.
                throw new Error('eventType ' + type + ' unsupported! (code should not reach here)');
        }
    }
    stopGrpcStream() {
        config_1.log.verbose('PuppetHostie', 'stopGrpcStream()');
        if (!this.eventStream) {
            throw new Error('no event stream');
        }
        /**
         * Huan(202003):
         *  destroy() will be enough to terminate a stream call.
         *  cancel() is not needed.
         */
        // this.eventStream.cancel()
        this.eventStream.destroy();
        this.eventStream = undefined;
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'logout()');
            if (!this.id) {
                throw new Error('logout before login?');
            }
            try {
                yield util_1.default.promisify(this.grpcClient.logout.bind(this.grpcClient)
                    .bind(this.grpcClient))(new grpc_2.LogoutRequest());
            }
            catch (e) {
                config_1.log.error('PuppetHostie', 'logout() rejection: %s', e && e.message);
                throw e;
            }
            finally {
                const payload = { contactId: this.id };
                this.emit('logout', payload); // becore we will throw above by logonoff() when this.user===undefined
                this.id = undefined;
            }
        });
    }
    ding(data) {
        config_1.log.silly('PuppetHostie', 'ding(%s)', data);
        const request = new grpc_2.DingRequest();
        request.setData(data || '');
        this.grpcClient.ding(request, (error, _response) => {
            if (error) {
                config_1.log.error('PuppetHostie', 'ding() rejection: %s', error);
            }
        });
    }
    unref() {
        config_1.log.verbose('PuppetHostie', 'unref()');
        super.unref();
    }
    contactAlias(contactId, alias) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactAlias(%s, %s)', contactId, alias);
            /**
             * Get alias
             */
            if (typeof alias === 'undefined') {
                const request = new grpc_2.ContactAliasRequest();
                request.setId(contactId);
                const response = yield util_1.default.promisify(this.grpcClient.contactAlias.bind(this.grpcClient))(request);
                const aliasWrapper = response.getAlias();
                if (!aliasWrapper) {
                    throw new Error('can not get aliasWrapper');
                }
                return aliasWrapper.getValue();
            }
            /**
             * Set alias
             */
            const aliasWrapper = new grpc_2.StringValue();
            aliasWrapper.setValue(alias || ''); // null -> '', in server, we treat '' as null
            const request = new grpc_2.ContactAliasRequest();
            request.setId(contactId);
            request.setAlias(aliasWrapper);
            yield util_1.default.promisify(this.grpcClient.contactAlias.bind(this.grpcClient))(request);
        });
    }
    contactList() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactList()');
            const response = yield util_1.default.promisify(this.grpcClient.contactList.bind(this.grpcClient))(new grpc_2.ContactListRequest());
            return response.getIdsList();
        });
    }
    contactQRCode(contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (contactId !== this.selfId()) {
                throw new Error('can not set avatar for others');
            }
            const response = yield util_1.default.promisify(this.grpcClient.contactSelfQRCode.bind(this.grpcClient))(new grpc_2.ContactSelfQRCodeRequest());
            return response.getQrcode();
        });
    }
    contactAvatar(contactId, fileBox) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactAvatar(%s)', contactId);
            /**
             * 1. set
             */
            if (fileBox) {
                const fileboxWrapper = new grpc_2.StringValue();
                fileboxWrapper.setValue(JSON.stringify(fileBox));
                const request = new grpc_2.ContactAvatarRequest();
                request.setId(contactId);
                request.setFilebox(fileboxWrapper);
                yield util_1.default.promisify(this.grpcClient.contactSelfQRCode.bind(this.grpcClient))(request);
                return;
            }
            /**
             * 2. get
             */
            const request = new grpc_2.ContactAvatarRequest();
            request.setId(contactId);
            const response = yield util_1.default.promisify(this.grpcClient.contactSelfQRCode.bind(this.grpcClient))(request);
            const qrcode = response.getQrcode();
            return wechaty_puppet_1.FileBox.fromQRCode(qrcode);
        });
    }
    contactRawPayload(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactRawPayload(%s)', id);
            const request = new grpc_2.ContactPayloadRequest();
            request.setId(id);
            const response = yield util_1.default.promisify(this.grpcClient.contactPayload.bind(this.grpcClient))(request);
            const payload = {
                address: response.getAddress(),
                alias: response.getAlias(),
                avatar: response.getAvatar(),
                city: response.getCity(),
                friend: response.getFriend(),
                gender: response.getGender(),
                id: response.getId(),
                name: response.getName(),
                province: response.getProvince(),
                signature: response.getSignature(),
                star: response.getStar(),
                type: response.getType(),
                weixin: response.getWeixin(),
            };
            return payload;
        });
    }
    contactRawPayloadParser(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // log.silly('PuppetHostie', 'contactRawPayloadParser({id:%s})', payload.id)
            // passthrough
            return payload;
        });
    }
    contactSelfName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactSelfName(%s)', name);
            const request = new grpc_2.ContactSelfNameRequest();
            request.setName(name);
            yield util_1.default.promisify(this.grpcClient.contactSelfName.bind(this.grpcClient))(request);
        });
    }
    contactSelfQRCode() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactSelfQRCode()');
            const response = yield util_1.default.promisify(this.grpcClient.contactSelfQRCode.bind(this.grpcClient))(new grpc_2.ContactSelfQRCodeRequest());
            return response.getQrcode();
        });
    }
    contactSelfSignature(signature) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'contactSelfSignature(%s)', signature);
            const request = new grpc_2.ContactSelfSignatureRequest();
            request.setSignature(signature);
            yield util_1.default.promisify(this.grpcClient.contactSelfSignature.bind(this.grpcClient))(request);
        });
    }
    /**
     *
     * Message
     *
     */
    messageMiniProgram(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageMiniProgram(%s)', messageId);
            const request = new grpc_2.MessageMiniProgramRequest();
            request.setId(messageId);
            const response = yield util_1.default.promisify(this.grpcClient.messageMiniProgram.bind(this.grpcClient))(request);
            const jsonText = response.getMiniProgram();
            const payload = JSON.parse(jsonText);
            return payload;
        });
    }
    messageImage(messageId, imageType) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageImage(%s, %s[%s])', messageId, imageType, wechaty_puppet_1.ImageType[imageType]);
            const request = new grpc_2.MessageImageRequest();
            request.setId(messageId);
            request.setType(imageType);
            const response = yield util_1.default.promisify(this.grpcClient.messageImage.bind(this.grpcClient))(request);
            const jsonText = response.getFilebox();
            return wechaty_puppet_1.FileBox.fromJSON(jsonText);
        });
    }
    messageContact(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageContact(%s)', messageId);
            const request = new grpc_2.MessageContactRequest();
            request.setId(messageId);
            const response = yield util_1.default.promisify(this.grpcClient.messageContact.bind(this.grpcClient))(request);
            const contactId = response.getId();
            return contactId;
        });
    }
    messageSendMiniProgram(conversationId, miniProgramPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageSendMiniProgram(%s)', conversationId, JSON.stringify(miniProgramPayload));
            const request = new grpc_2.MessageSendMiniProgramRequest();
            request.setConversationId(conversationId);
            request.setMiniProgram(JSON.stringify(miniProgramPayload));
            const response = yield util_1.default.promisify(this.grpcClient.messageSendMiniProgram.bind(this.grpcClient))(request);
            const messageIdWrapper = response.getId();
            if (messageIdWrapper) {
                return messageIdWrapper.getValue();
            }
        });
    }
    messageRecall(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageRecall(%s)', messageId);
            const request = new grpc_2.MessageRecallRequest();
            request.setId(messageId);
            const response = yield util_1.default.promisify(this.grpcClient.messageRecall.bind(this.grpcClient))(request);
            return response.getSuccess();
        });
    }
    messageFile(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageFile(%s)', id);
            const request = new grpc_2.MessageFileRequest();
            request.setId(id);
            const response = yield util_1.default.promisify(this.grpcClient.messageFile.bind(this.grpcClient))(request);
            const jsonText = response.getFilebox();
            return wechaty_puppet_1.FileBox.fromJSON(jsonText);
        });
    }
    messageRawPayload(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageRawPayload(%s)', id);
            const request = new grpc_2.MessagePayloadRequest();
            request.setId(id);
            const response = yield util_1.default.promisify(this.grpcClient.messagePayload.bind(this.grpcClient))(request);
            const payload = {
                filename: response.getFilename(),
                fromId: response.getFromId(),
                id: response.getId(),
                mentionIdList: response.getMentionIdsList(),
                roomId: response.getRoomId(),
                text: response.getText(),
                timestamp: response.getTimestamp(),
                toId: response.getToId(),
                type: response.getType(),
            };
            return payload;
        });
    }
    messageRawPayloadParser(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // log.silly('PuppetHostie', 'messagePayload({id:%s})', payload.id)
            // passthrough
            return payload;
        });
    }
    messageSendText(conversationId, text) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageSend(%s, %s)', conversationId, text);
            const request = new grpc_2.MessageSendTextRequest();
            request.setConversationId(conversationId);
            request.setText(text);
            const response = yield util_1.default.promisify(this.grpcClient.messageSendText.bind(this.grpcClient))(request);
            const messageIdWrapper = response.getId();
            if (messageIdWrapper) {
                return messageIdWrapper.getValue();
            }
        });
    }
    messageSendFile(conversationId, file) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageSend(%s, %s)', conversationId, file);
            const request = new grpc_2.MessageSendFileRequest();
            request.setConversationId(conversationId);
            request.setFilebox(JSON.stringify(file));
            const response = yield util_1.default.promisify(this.grpcClient.messageSendFile.bind(this.grpcClient))(request);
            const messageIdWrapper = response.getId();
            if (messageIdWrapper) {
                return messageIdWrapper.getValue();
            }
        });
    }
    messageSendContact(conversationId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageSend("%s", %s)', conversationId, contactId);
            const request = new grpc_2.MessageSendContactRequest();
            request.setConversationId(conversationId);
            request.setContactId(contactId);
            const response = yield util_1.default.promisify(this.grpcClient.messageSendContact.bind(this.grpcClient))(request);
            const messageIdWrapper = response.getId();
            if (messageIdWrapper) {
                return messageIdWrapper.getValue();
            }
        });
    }
    messageSendUrl(conversationId, urlLinkPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageSendUrl("%s", %s)', conversationId, JSON.stringify(urlLinkPayload));
            const request = new grpc_2.MessageSendUrlRequest();
            request.setConversationId(conversationId);
            request.setUrlLink(JSON.stringify(urlLinkPayload));
            const response = yield util_1.default.promisify(this.grpcClient.messageSendUrl.bind(this.grpcClient))(request);
            const messageIdWrapper = response.getId();
            if (messageIdWrapper) {
                return messageIdWrapper.getValue();
            }
        });
    }
    messageUrl(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'messageUrl(%s)', messageId);
            const request = new grpc_2.MessageUrlRequest();
            request.setId(messageId);
            const response = yield util_1.default.promisify(this.grpcClient.messageUrl.bind(this.grpcClient))(request);
            const jsonText = response.getUrlLink();
            const payload = JSON.parse(jsonText);
            return payload;
        });
    }
    /**
     *
     * Room
     *
     */
    roomRawPayload(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomRawPayload(%s)', id);
            const request = new grpc_2.RoomPayloadRequest();
            request.setId(id);
            const response = yield util_1.default.promisify(this.grpcClient.roomPayload.bind(this.grpcClient))(request);
            const payload = {
                adminIdList: response.getAdminIdsList(),
                avatar: response.getAvatar(),
                id: response.getId(),
                memberIdList: response.getMemberIdsList(),
                ownerId: response.getOwnerId(),
                topic: response.getTopic(),
            };
            return payload;
        });
    }
    roomRawPayloadParser(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // log.silly('PuppetHostie', 'roomRawPayloadParser({id:%s})', payload.id)
            // passthrough
            return payload;
        });
    }
    roomList() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomList()');
            const response = yield util_1.default.promisify(this.grpcClient.roomList.bind(this.grpcClient))(new grpc_2.RoomListRequest());
            return response.getIdsList();
        });
    }
    roomDel(roomId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomDel(%s, %s)', roomId, contactId);
            const request = new grpc_2.RoomDelRequest();
            request.setId(roomId);
            request.setContactId(contactId);
            yield util_1.default.promisify(this.grpcClient.roomDel.bind(this.grpcClient))(request);
        });
    }
    roomAvatar(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomAvatar(%s)', roomId);
            const request = new grpc_2.RoomAvatarRequest();
            request.setId(roomId);
            const response = yield util_1.default.promisify(this.grpcClient.roomAvatar.bind(this.grpcClient))(request);
            const jsonText = response.getFilebox();
            return wechaty_puppet_1.FileBox.fromJSON(jsonText);
        });
    }
    roomAdd(roomId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomAdd(%s, %s)', roomId, contactId);
            const request = new grpc_2.RoomAddRequest();
            request.setId(roomId);
            request.setContactId(contactId);
            yield util_1.default.promisify(this.grpcClient.roomAdd.bind(this.grpcClient))(request);
        });
    }
    roomTopic(roomId, topic) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomTopic(%s, %s)', roomId, topic);
            /**
             * Get
             */
            if (typeof topic === 'undefined') {
                const request = new grpc_2.RoomTopicRequest();
                request.setId(roomId);
                const response = yield util_1.default.promisify(this.grpcClient.roomTopic.bind(this.grpcClient))(request);
                const topicWrapper = response.getTopic();
                if (topicWrapper) {
                    return topicWrapper.getValue();
                }
                return '';
            }
            /**
             * Set
             */
            const topicWrapper = new grpc_2.StringValue();
            topicWrapper.setValue(topic);
            const request = new grpc_2.RoomTopicRequest();
            request.setId(roomId);
            request.setTopic(topicWrapper);
            yield util_1.default.promisify(this.grpcClient.roomTopic.bind(this.grpcClient))(request);
        });
    }
    roomCreate(contactIdList, topic) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomCreate(%s, %s)', contactIdList, topic);
            const request = new grpc_2.RoomCreateRequest();
            request.setContactIdsList(contactIdList);
            request.setTopic(topic);
            const response = yield util_1.default.promisify(this.grpcClient.roomCreate.bind(this.grpcClient))(request);
            return response.getId();
        });
    }
    roomQuit(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomQuit(%s)', roomId);
            const request = new grpc_2.RoomQuitRequest();
            request.setId(roomId);
            yield util_1.default.promisify(this.grpcClient.roomQuit.bind(this.grpcClient))(request);
        });
    }
    roomQRCode(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomQRCode(%s)', roomId);
            const request = new grpc_2.RoomQRCodeRequest();
            request.setId(roomId);
            const response = yield util_1.default.promisify(this.grpcClient.roomQRCode.bind(this.grpcClient))(request);
            return response.getQrcode();
        });
    }
    roomMemberList(roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roommemberList(%s)', roomId);
            const request = new grpc_2.RoomMemberListRequest();
            request.setId(roomId);
            const response = yield util_1.default.promisify(this.grpcClient.roomMemberList.bind(this.grpcClient))(request);
            return response.getMemberIdsList();
        });
    }
    roomMemberRawPayload(roomId, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomMemberRawPayload(%s, %s)', roomId, contactId);
            const request = new grpc_2.RoomMemberPayloadRequest();
            request.setId(roomId);
            request.setMemberId(contactId);
            const response = yield util_1.default.promisify(this.grpcClient.roomMemberPayload.bind(this.grpcClient))(request);
            const payload = {
                avatar: response.getAvatar(),
                id: response.getId(),
                inviterId: response.getInviterId(),
                name: response.getName(),
                roomAlias: response.getRoomAlias(),
            };
            return payload;
        });
    }
    roomMemberRawPayloadParser(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // log.silly('PuppetHostie', 'roomMemberRawPayloadParser({id:%s})', payload.id)
            // passthrough
            return payload;
        });
    }
    roomAnnounce(roomId, text) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomAnnounce(%s%s)', roomId, typeof text === 'undefined'
                ? ''
                : `, ${text}`);
            /**
             * Set
             */
            if (text) {
                const textWrapper = new grpc_2.StringValue();
                textWrapper.setValue(text);
                const request = new grpc_2.RoomAnnounceRequest();
                request.setId(roomId);
                request.setText(textWrapper);
                yield util_1.default.promisify(this.grpcClient.roomAnnounce.bind(this.grpcClient))(request);
                return;
            }
            /**
             * Get
             */
            const request = new grpc_2.RoomAnnounceRequest();
            request.setId(roomId);
            const response = yield util_1.default.promisify(this.grpcClient.roomAnnounce.bind(this.grpcClient))(request);
            const textWrapper = response.getText();
            if (textWrapper) {
                return textWrapper.getValue();
            }
            return '';
        });
    }
    roomInvitationAccept(roomInvitationId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomInvitationAccept(%s)', roomInvitationId);
            const request = new grpc_2.RoomInvitationAcceptRequest();
            request.setId(roomInvitationId);
            yield util_1.default.promisify(this.grpcClient.roomInvitationAccept.bind(this.grpcClient))(request);
        });
    }
    roomInvitationRawPayload(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'roomInvitationRawPayload(%s)', id);
            const request = new grpc_2.RoomInvitationPayloadRequest();
            request.setId(id);
            const response = yield util_1.default.promisify(this.grpcClient.roomInvitationPayload.bind(this.grpcClient))(request);
            const payload = {
                avatar: response.getAvatar(),
                id: response.getId(),
                invitation: response.getInvitation(),
                inviterId: response.getInviterId(),
                memberCount: response.getMemberCount(),
                memberIdList: response.getMemberIdsList(),
                receiverId: response.getReceiverId(),
                timestamp: response.getTimestamp(),
                topic: response.getTopic(),
            };
            return payload;
        });
    }
    roomInvitationRawPayloadParser(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // log.silly('PuppetHostie', 'roomInvitationRawPayloadParser({id:%s})', payload.id)
            // passthrough
            return payload;
        });
    }
    /**
     *
     * Friendship
     *
     */
    friendshipSearchPhone(phone) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'friendshipSearchPhone(%s)', phone);
            const request = new grpc_2.FriendshipSearchPhoneRequest();
            request.setPhone(phone);
            const response = yield util_1.default.promisify(this.grpcClient.friendshipSearchPhone.bind(this.grpcClient))(request);
            const contactIdWrapper = response.getContactId();
            if (contactIdWrapper) {
                return contactIdWrapper.getValue();
            }
            return null;
        });
    }
    friendshipSearchWeixin(weixin) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'friendshipSearchWeixin(%s)', weixin);
            const request = new grpc_2.FriendshipSearchWeixinRequest();
            request.setWeixin(weixin);
            const response = yield util_1.default.promisify(this.grpcClient.friendshipSearchWeixin.bind(this.grpcClient))(request);
            const contactIdWrapper = response.getContactId();
            if (contactIdWrapper) {
                return contactIdWrapper.getValue();
            }
            return null;
        });
    }
    friendshipRawPayload(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'friendshipRawPayload(%s)', id);
            const request = new grpc_2.FriendshipPayloadRequest();
            request.setId(id);
            const response = yield util_1.default.promisify(this.grpcClient.friendshipPayload.bind(this.grpcClient))(request);
            const payload = {
                scene: response.getScene(),
                stranger: response.getStranger(),
                ticket: response.getTicket(),
                type: response.getType(),
            }; // FIXME: Huan(202002)
            return payload;
        });
    }
    friendshipRawPayloadParser(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // log.silly('PuppetHostie', 'friendshipRawPayloadParser({id:%s})', payload.id)
            // passthrough
            return payload;
        });
    }
    friendshipAdd(contactId, hello) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'friendshipAdd(%s, %s)', contactId, hello);
            const request = new grpc_2.FriendshipAddRequest();
            request.setContactId(contactId);
            request.setHello(hello);
            yield util_1.default.promisify(this.grpcClient.friendshipAdd.bind(this.grpcClient))(request);
        });
    }
    friendshipAccept(friendshipId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'friendshipAccept(%s)', friendshipId);
            const request = new grpc_2.FriendshipAcceptRequest();
            request.setId(friendshipId);
            yield util_1.default.promisify(this.grpcClient.frendshipAccept.bind(this.grpcClient))(request);
        });
    }
    /**
     *
     * Tag
     *
     */
    // add a tag for a Contact. Create it first if it not exist.
    tagContactAdd(id, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'tagContactAdd(%s, %s)', id, contactId);
            const request = new grpc_2.TagContactAddRequest();
            request.setId(id);
            request.setContactId(contactId);
            yield util_1.default.promisify(this.grpcClient.tagContactAdd.bind(this.grpcClient))(request);
        });
    }
    // remove a tag from the Contact
    tagContactRemove(id, contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'tagContactRemove(%s, %s)', id, contactId);
            const request = new grpc_2.TagContactRemoveRequest();
            request.setId(id);
            request.setContactId(contactId);
            yield util_1.default.promisify(this.grpcClient.tagContactRemove.bind(this.grpcClient))(request);
        });
    }
    // delete a tag from Wechat
    tagContactDelete(id) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'tagContactDelete(%s)', id);
            const request = new grpc_2.TagContactDeleteRequest();
            request.setId(id);
            yield util_1.default.promisify(this.grpcClient.tagContactDelete.bind(this.grpcClient))(request);
        });
    }
    // get tags from a specific Contact
    tagContactList(contactId) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetHostie', 'tagContactList(%s)', contactId);
            const request = new grpc_2.TagContactListRequest();
            if (typeof contactId !== 'undefined') {
                const contactIdWrapper = new grpc_2.StringValue();
                contactIdWrapper.setValue(contactId);
                request.setContactId(contactIdWrapper);
            }
            const response = yield util_1.default.promisify(this.grpcClient.tagContactList.bind(this.grpcClient))(request);
            return response.getIdsList();
        });
    }
}
exports.PuppetHostie = PuppetHostie;
PuppetHostie.VERSION = config_1.VERSION;
exports.default = PuppetHostie;
//# sourceMappingURL=puppet-hostie.js.map