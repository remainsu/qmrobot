"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const grpc_1 = require("@chatie/grpc");
const wechaty_puppet_1 = require("wechaty-puppet");
const config_1 = require("../config");
const event_type_rev_1 = require("../event-type-rev");
class EventStreamManager {
    constructor(puppet) {
        this.puppet = puppet;
        config_1.log.verbose('EventStreamManager', 'constructor(%s)', puppet);
    }
    busy() {
        return !!this.eventStream;
    }
    start(stream) {
        config_1.log.verbose('EventStreamManager', 'start(stream)');
        if (this.eventStream) {
            throw new Error('can not set twice');
        }
        this.eventStream = stream;
        const unconnect = this.connectPuppetEventToStreamingCall();
        this.onStreamingCallEnd(unconnect);
        /**
          * We emit the login event if current the puppet is logged in.
          */
        if (this.puppet.logonoff()) {
            config_1.log.verbose('EventStreamManager', 'start() puppet is logged in, emit a login event for downstream');
            const payload = {
                contactId: this.puppet.selfId(),
            };
            this.grpcEmit(grpc_1.EventType.EVENT_TYPE_LOGIN, payload);
        }
    }
    stop() {
        config_1.log.verbose('EventStreamManager', 'stop()');
        if (!this.eventStream) {
            throw new Error('no this.eventStream');
        }
        this.eventStream.end();
        this.eventStream = undefined;
    }
    grpcEmit(type, // https://stackoverflow.com/a/49286056/1123955
    obj) {
        config_1.log.verbose('EventStreamManager', 'grpcEmit(%s[%s], %s)', event_type_rev_1.EventTypeRev[type], type, JSON.stringify(obj));
        const response = new grpc_1.EventResponse();
        response.setType(type);
        response.setPayload(JSON.stringify(obj));
        if (this.eventStream) {
            this.eventStream.write(response);
        }
        else {
            config_1.log.warn('EventStreamManager', 'grpcEmit(%s, %s) this.eventStream is undefined.', type, JSON.stringify(obj));
        }
    }
    connectPuppetEventToStreamingCall() {
        config_1.log.verbose('EventStreamManager', 'connectPuppetEventToStreamingCall() for %s', this.puppet);
        const offCallbackList = [];
        const unconnect = () => {
            config_1.log.verbose('EventStreamManager', 'connectPuppetEventToStreamingCall() unconnect() %s callbacks', offCallbackList.length);
            offCallbackList.forEach(cb => cb());
        };
        const eventNameList = Object.keys(wechaty_puppet_1.PUPPET_EVENT_DICT);
        for (const eventName of eventNameList) {
            config_1.log.verbose('EventStreamManager', 'connectPuppetEventToStreamingCall() this.puppet.on(%s) (listenerCount:%s) registering...', eventName, this.puppet.listenerCount(eventName));
            switch (eventName) {
                case 'dong': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_DONG, payload);
                    this.puppet.on('dong', listener);
                    const off = () => this.puppet.off('dong', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'error': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_ERROR, payload);
                    this.puppet.on('error', listener);
                    const off = () => this.puppet.off('error', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'heartbeat': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_HEARTBEAT, payload);
                    this.puppet.on('heartbeat', listener);
                    const off = () => this.puppet.off('heartbeat', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'friendship': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_FRIENDSHIP, payload);
                    this.puppet.on('friendship', listener);
                    const off = () => this.puppet.off('friendship', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'login': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_LOGIN, payload);
                    this.puppet.on('login', listener);
                    const off = () => this.puppet.off('login', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'logout': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_LOGOUT, payload);
                    this.puppet.on('logout', listener);
                    const off = () => this.puppet.off('logout', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'message': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_MESSAGE, payload);
                    this.puppet.on('message', listener);
                    const off = () => this.puppet.off('message', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'ready': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_READY, payload);
                    this.puppet.on('ready', listener);
                    const off = () => this.puppet.off('ready', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'room-invite': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_ROOM_INVITE, payload);
                    this.puppet.on('room-invite', listener);
                    const off = () => this.puppet.off('room-invite', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'room-join': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_ROOM_JOIN, payload);
                    this.puppet.on('room-join', listener);
                    const off = () => this.puppet.off('room-join', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'room-leave': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_ROOM_LEAVE, payload);
                    this.puppet.on('room-leave', listener);
                    const off = () => this.puppet.off('room-leave', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'room-topic': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_ROOM_TOPIC, payload);
                    this.puppet.on('room-topic', listener);
                    const off = () => this.puppet.off('room-topic', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'scan': {
                    const listener = (payload) => this.grpcEmit(grpc_1.EventType.EVENT_TYPE_SCAN, payload);
                    this.puppet.on('scan', listener);
                    const off = () => this.puppet.off('scan', listener);
                    offCallbackList.push(off);
                    break;
                }
                case 'reset':
                    // the `reset` event should be dealed internally, should not send out
                    break;
                default:
                    // Huan(202003): in default, the `eventName` type should be `never`, please check.
                    throw new Error('eventName ' + eventName + ' unsupported!');
            }
        }
        return unconnect;
    }
    /**
     * Detect if the streaming call was gone (GRPC disconnects)
     *  https://github.com/grpc/grpc/issues/8117#issuecomment-362198092
     */
    onStreamingCallEnd(callback) {
        config_1.log.verbose('EventStreamManager', 'onStreamingCallEnd(callback)');
        if (!this.eventStream) {
            throw new Error('no this.eventStream found');
        }
        this.eventStream.on('cancelled', () => {
            config_1.log.verbose('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(cancelled) fired with arguments: %s', JSON.stringify(arguments));
            if (this.eventStream) {
                callback();
                this.eventStream = undefined;
            }
            else {
                config_1.log.warn('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(cancelled) eventStream is undefined');
            }
        });
        this.eventStream.on('error', err => {
            config_1.log.verbose('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(error) fired: %s', err);
            if (this.eventStream) {
                callback();
                this.eventStream = undefined;
            }
            else {
                config_1.log.warn('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(error) eventStream is undefined');
            }
        });
        this.eventStream.on('finish', () => {
            config_1.log.verbose('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(finish) fired');
            if (this.eventStream) {
                callback();
                this.eventStream = undefined;
            }
            else {
                config_1.log.warn('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(finish) eventStream is undefined');
            }
        });
        this.eventStream.on('end', () => {
            config_1.log.verbose('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(end) fired');
            if (this.eventStream) {
                callback();
                this.eventStream = undefined;
            }
            else {
                config_1.log.warn('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(end) eventStream is undefined');
            }
        });
        this.eventStream.on('close', () => {
            config_1.log.verbose('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(close) fired');
            if (this.eventStream) {
                callback();
                this.eventStream = undefined;
            }
            else {
                config_1.log.warn('EventStreamManager', 'this.onStreamingCallEnd() this.eventStream.on(close) eventStream is undefined');
            }
        });
    }
}
exports.EventStreamManager = EventStreamManager;
//# sourceMappingURL=event-stream-manager.js.map