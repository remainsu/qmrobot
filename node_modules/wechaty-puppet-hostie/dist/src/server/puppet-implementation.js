"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc_1 = __importDefault(require("grpc"));
const grpc_2 = require("@chatie/grpc");
const wechaty_puppet_1 = require("wechaty-puppet");
const config_1 = require("../config");
const grpc_error_1 = require("./grpc-error");
const event_stream_manager_1 = require("./event-stream-manager");
/**
 * Implements the SayHello RPC method.
 */
function puppetImplementation(puppet) {
    /**
     * Save scan payload to send it to the puppet-hostie right after connected (if needed)
     *
     * TODO: clean the listeners if necessary
     */
    let scanPayload;
    puppet.on('scan', payload => { scanPayload = payload; });
    puppet.on('login', _ => { scanPayload = undefined; });
    const eventStreamManager = new event_stream_manager_1.EventStreamManager(puppet);
    const puppetServerImpl = {
        contactAlias: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactAlias()');
            const id = call.request.getId();
            /**
             * Set
             */
            {
                const aliasWrapper = call.request.getAlias();
                if (aliasWrapper) {
                    try {
                        yield puppet.contactAlias(id, aliasWrapper.getValue());
                        return callback(null, new grpc_2.ContactAliasResponse());
                    }
                    catch (e) {
                        return grpc_error_1.grpcError('contactAlias', e, callback);
                    }
                }
            }
            /**
             * Get
             */
            try {
                const alias = yield puppet.contactAlias(id);
                const aliasWrapper = new grpc_2.StringValue();
                aliasWrapper.setValue(alias);
                const response = new grpc_2.ContactAliasResponse();
                response.setAlias(aliasWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactAlias', e, callback);
            }
        }),
        contactAvatar: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactAvatar()');
            const id = call.request.getId();
            /**
             * Set
             */
            try {
                const fileBoxWrapper = call.request.getFilebox();
                if (fileBoxWrapper) {
                    const fileBox = wechaty_puppet_1.FileBox.fromJSON(fileBoxWrapper.getValue());
                    yield puppet.contactAvatar(id, fileBox);
                    return callback(null, new grpc_2.ContactAvatarResponse());
                }
            }
            catch (e) {
                return grpc_error_1.grpcError('contactAvatar', e, callback);
            }
            /**
             * Get
             */
            try {
                const fileBox = yield puppet.contactAvatar(id);
                const fileBoxWrapper = new grpc_2.StringValue();
                fileBoxWrapper.setValue(JSON.stringify(fileBox));
                const response = new grpc_2.ContactAvatarResponse();
                response.setFilebox(fileBoxWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactAvatar', e, callback);
            }
        }),
        contactList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactList()');
            void call; // empty request
            try {
                const idList = yield puppet.contactList();
                const response = new grpc_2.ContactListResponse();
                response.setIdsList(idList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactList', e, callback);
            }
        }),
        contactPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactPayload()');
            const id = call.request.getId();
            try {
                const payload = yield puppet.contactPayload(id);
                const response = new grpc_2.ContactPayloadResponse();
                response.setAddress(payload.address || '');
                response.setAlias(payload.alias || '');
                response.setAvatar(payload.avatar);
                response.setCity(payload.city || '');
                response.setFriend(payload.friend || false);
                response.setGender(payload.gender);
                response.setId(payload.id);
                response.setName(payload.name);
                response.setProvince(payload.province || '');
                response.setSignature(payload.signature || '');
                response.setStar(payload.star || false);
                response.setType(payload.type);
                response.setWeixin(payload.weixin || '');
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactPayload', e, callback);
            }
        }),
        contactSelfName: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactSelfName()');
            try {
                const name = call.request.getName();
                yield puppet.contactSelfName(name);
                return callback(null, new grpc_2.ContactSelfNameResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactSelfName', e, callback);
            }
        }),
        contactSelfQRCode: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactSelfName()');
            void call;
            try {
                const qrcode = yield puppet.contactSelfQRCode();
                const response = new grpc_2.ContactSelfQRCodeResponse();
                response.setQrcode(qrcode);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactSelfQRCode', e, callback);
            }
        }),
        contactSelfSignature: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'contactSelfSignature()');
            try {
                const signature = call.request.getSignature();
                yield puppet.contactSelfSignature(signature);
                return callback(null, new grpc_2.ContactSelfSignatureResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactSelfSignature', e, callback);
            }
        }),
        ding: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'ding()');
            try {
                const data = call.request.getData();
                yield puppet.ding(data);
                return callback(null, new grpc_2.DingResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('ding', e, callback);
            }
        }),
        /**
         *
         * Bridge Event Emitter Events
         *
         */
        event: (streamingCall) => {
            config_1.log.verbose('PuppetServiceImpl', 'event()');
            if (eventStreamManager.busy()) {
                config_1.log.error('PuppetServiceImpl', 'event() there is another event() call not end when receiving a new one.');
                const error = Object.assign(Object.assign({}, new Error('GrpcServerImpl.event() can not call twice.')), { code: grpc_1.default.status.ALREADY_EXISTS, details: 'GrpcServerImpl.event() can not call twice.' });
                /**
                  * Send error from gRPC server stream:
                  *  https://github.com/grpc/grpc-node/issues/287#issuecomment-383218225
                  *
                  * Streaming RPCs
                  *  - https://grpc.io/docs/tutorials/basic/node/
                  *    Only one of 'error' or 'end' will be emitted. Finally, the 'status' event fires when the server sends the status.
                  */
                streamingCall.emit('error', error);
                return;
            }
            eventStreamManager.start(streamingCall);
            /**
             * If `scanPayload` is not undefined, then we emit it to downstream immediatelly
             */
            if (scanPayload) {
                eventStreamManager.grpcEmit(grpc_2.EventType.EVENT_TYPE_SCAN, scanPayload);
            }
        },
        frendshipAccept: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipAccept()');
            try {
                const id = call.request.getId();
                yield puppet.friendshipAccept(id);
                return callback(null, new grpc_2.FriendshipAcceptResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipAccept', e, callback);
            }
        }),
        friendshipAdd: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipAccept()');
            try {
                const contactId = call.request.getContactId();
                const hello = call.request.getHello();
                yield puppet.friendshipAdd(contactId, hello);
                return callback(null, new grpc_2.FriendshipAddResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipAdd', e, callback);
            }
        }),
        friendshipPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipAccept()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.friendshipPayload(id);
                const payloadReceive = payload;
                const response = new grpc_2.FriendshipPayloadResponse();
                response.setContactId(payload.id);
                response.setHello(payload.hello || '');
                response.setId(payload.id);
                response.setScene(payloadReceive.scene || wechaty_puppet_1.FriendshipSceneType.Unknown);
                response.setStranger(payloadReceive.stranger || '');
                response.setTicket(payloadReceive.ticket);
                response.setType(payload.type);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipPayload', e, callback);
            }
        }),
        friendshipSearchPhone: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipSearchPhone()');
            try {
                const phone = call.request.getPhone();
                const contactId = yield puppet.friendshipSearchPhone(phone);
                const response = new grpc_2.FriendshipSearchPhoneResponse();
                if (contactId) {
                    const contactIdWrapper = new grpc_2.StringValue();
                    contactIdWrapper.setValue(contactId);
                    response.setContactId(contactIdWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipSearchPhone', e, callback);
            }
        }),
        friendshipSearchWeixin: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipSearchWeixin()');
            try {
                const weixin = call.request.getWeixin();
                const contactId = yield puppet.friendshipSearchWeixin(weixin);
                const response = new grpc_2.FriendshipSearchWeixinResponse();
                if (contactId) {
                    const contactIdWrapper = new grpc_2.StringValue();
                    contactIdWrapper.setValue(contactId);
                    response.setContactId(contactIdWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipSearchWeixin', e, callback);
            }
        }),
        logout: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'logout()');
            void call; // empty arguments
            try {
                yield puppet.logout();
                return callback(null, new grpc_2.LogoutResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('logout', e, callback);
            }
        }),
        messageContact: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageContact()');
            try {
                const id = call.request.getId();
                const contactId = yield puppet.messageContact(id);
                const response = new grpc_2.MessageContactResponse();
                response.setId(contactId);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageContact', e, callback);
            }
        }),
        messageFile: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageFile()');
            try {
                const id = call.request.getId();
                const fileBox = yield puppet.messageFile(id);
                const response = new grpc_2.MessageFileResponse();
                response.setFilebox(JSON.stringify(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageFile', e, callback);
            }
        }),
        messageImage: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageImage()');
            try {
                const id = call.request.getId();
                const type = call.request.getType();
                const fileBox = yield puppet.messageImage(id, type);
                const response = new grpc_2.MessageImageResponse();
                response.setFilebox(JSON.stringify(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageImage', e, callback);
            }
        }),
        messageMiniProgram: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageMiniProgram()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.messageMiniProgram(id);
                const response = new grpc_2.MessageMiniProgramResponse();
                response.setMiniProgram(JSON.stringify(payload));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageMiniProgram', e, callback);
            }
        }),
        messagePayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messagePayload()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.messagePayload(id);
                const response = new grpc_2.MessagePayloadResponse();
                response.setFilename(payload.filename || '');
                response.setFromId(payload.fromId || '');
                response.setId(payload.id);
                response.setMentionIdsList(payload.mentionIdList);
                response.setRoomId(payload.roomId || '');
                response.setText(payload.text || '');
                response.setTimestamp(payload.timestamp);
                response.setToId(payload.toId || '');
                response.setType(payload.type);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messagePayload', e, callback);
            }
        }),
        messageRecall: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageRecall()');
            try {
                const id = call.request.getId();
                const success = yield puppet.messageRecall(id);
                const response = new grpc_2.MessageRecallResponse();
                response.setSuccess(success);
                return callback(null, response);
            }
            catch (e) {
                grpc_error_1.grpcError('messageRecall', e, callback);
            }
        }),
        messageSendContact: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendContact()');
            try {
                const conversationId = call.request.getConversationId();
                const contactId = call.request.getContactId();
                const messageId = yield puppet.messageSendContact(conversationId, contactId);
                const response = new grpc_2.MessageSendContactResponse();
                if (messageId) {
                    const idWrapper = new grpc_2.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendContact', e, callback);
            }
        }),
        messageSendFile: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendFile()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getFilebox();
                const fileBox = wechaty_puppet_1.FileBox.fromJSON(jsonText);
                const messageId = yield puppet.messageSendFile(conversationId, fileBox);
                const response = new grpc_2.MessageSendFileResponse();
                if (messageId) {
                    const idWrapper = new grpc_2.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendFile', e, callback);
            }
        }),
        messageSendMiniProgram: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendMiniProgram()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getMiniProgram();
                const payload = JSON.parse(jsonText);
                const messageId = yield puppet.messageSendMiniProgram(conversationId, payload);
                const response = new grpc_2.MessageSendMiniProgramResponse();
                if (messageId) {
                    const idWrapper = new grpc_2.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendMiniProgram', e, callback);
            }
        }),
        messageSendText: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendText()');
            try {
                const conversationId = call.request.getConversationId();
                const text = call.request.getText();
                const mentionIdList = call.request.getMentonalIdsList();
                const messageId = yield puppet.messageSendText(conversationId, text, mentionIdList);
                const response = new grpc_2.MessageSendTextResponse();
                if (messageId) {
                    const idWrapper = new grpc_2.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendText', e, callback);
            }
        }),
        messageSendUrl: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendUrl()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getUrlLink();
                const payload = JSON.parse(jsonText);
                const messageId = yield puppet.messageSendUrl(conversationId, payload);
                const response = new grpc_2.MessageSendUrlResponse();
                if (messageId) {
                    const idWrapper = new grpc_2.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendUrl', e, callback);
            }
        }),
        messageUrl: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'messageUrl()');
            try {
                const id = call.request.getId();
                const payload = yield puppet.messageUrl(id);
                const response = new grpc_2.MessageUrlResponse();
                response.setUrlLink(JSON.stringify(payload));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageUrl', e, callback);
            }
        }),
        roomAdd: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomAdd()');
            try {
                const roomId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.roomAdd(roomId, contactId);
                return callback(null, new grpc_2.RoomAddResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomAdd', e, callback);
            }
        }),
        roomAnnounce: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomAnnounce()');
            try {
                const roomId = call.request.getId();
                /**
                 * Set
                 */
                {
                    const textWrapper = call.request.getText();
                    if (textWrapper) {
                        const text = textWrapper.getValue();
                        yield puppet.roomAnnounce(roomId, text);
                        return callback(null, new grpc_2.RoomAnnounceResponse());
                    }
                }
                /**
                 * Get
                 */
                const text = yield puppet.roomAnnounce(roomId);
                const textWrapper = new grpc_2.StringValue();
                textWrapper.setValue(text);
                const response = new grpc_2.RoomAnnounceResponse();
                response.setText(textWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomAnnounce', e, callback);
            }
        }),
        roomAvatar: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomAvatar()');
            try {
                const roomId = call.request.getId();
                const fileBox = yield puppet.roomAvatar(roomId);
                const response = new grpc_2.RoomAvatarResponse();
                response.setFilebox(JSON.stringify(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomAvatar', e, callback);
            }
        }),
        roomCreate: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomCreate()');
            try {
                const contactIdList = call.request.getContactIdsList();
                const topic = call.request.getTopic();
                const roomId = yield puppet.roomCreate(contactIdList, topic);
                const response = new grpc_2.RoomCreateResponse();
                response.setId(roomId);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomCreate', e, callback);
            }
        }),
        roomDel: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomDel()');
            try {
                const roomId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.roomDel(roomId, contactId);
                return callback(null, new grpc_2.RoomDelResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomDel', e, callback);
            }
        }),
        roomInvitationAccept: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomInvitationAccept()');
            try {
                const id = call.request.getId();
                yield puppet.roomInvitationAccept(id);
                return callback(null, new grpc_2.RoomInvitationAcceptResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomInvitationAccept', e, callback);
            }
        }),
        roomInvitationPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomInvitationPayload()');
            try {
                const roomInvitationId = call.request.getId();
                /**
                  * Set
                  */
                {
                    const payloadWrapper = call.request.getPayload();
                    if (payloadWrapper) {
                        const jsonText = payloadWrapper.getValue();
                        const payload = JSON.parse(jsonText);
                        yield puppet.roomInvitationPayload(roomInvitationId, payload);
                        return callback(null, new grpc_2.RoomInvitationPayloadResponse());
                    }
                }
                /**
                 * Get
                 */
                const payload = yield puppet.roomInvitationPayload(roomInvitationId);
                const response = new grpc_2.RoomInvitationPayloadResponse();
                response.setAvatar(payload.avatar);
                response.setId(payload.id);
                response.setInvitation(payload.invitation);
                response.setInviterId(payload.inviterId);
                response.setMemberCount(payload.memberCount);
                response.setMemberIdsList(payload.memberIdList);
                response.setTimestamp(payload.timestamp);
                response.setTopic(payload.topic);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomInvitationPayload', e, callback);
            }
        }),
        roomList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomList()');
            void call;
            try {
                const roomIdList = yield puppet.roomList();
                const response = new grpc_2.RoomListResponse();
                response.setIdsList(roomIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomList', e, callback);
            }
        }),
        roomMemberList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomMemberList()');
            try {
                const roomId = call.request.getId();
                const roomMemberIdList = yield puppet.roomMemberList(roomId);
                const response = new grpc_2.RoomMemberListResponse();
                response.setMemberIdsList(roomMemberIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomMemberList', e, callback);
            }
        }),
        roomMemberPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomMemberPayload()');
            try {
                const roomId = call.request.getId();
                const memberId = call.request.getMemberId();
                const payload = yield puppet.roomMemberPayload(roomId, memberId);
                const response = new grpc_2.RoomMemberPayloadResponse();
                response.setAvatar(payload.avatar);
                response.setId(payload.id);
                response.setInviterId(payload.inviterId || '');
                response.setName(payload.name);
                response.setRoomAlias(payload.roomAlias || '');
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomMemberPayload', e, callback);
            }
        }),
        roomPayload: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomPayload()');
            try {
                const roomId = call.request.getId();
                const payload = yield puppet.roomPayload(roomId);
                const response = new grpc_2.RoomPayloadResponse();
                response.setAdminIdsList(payload.adminIdList);
                response.setAvatar(payload.avatar || '');
                response.setId(payload.id);
                response.setMemberIdsList(payload.memberIdList);
                response.setOwnerId(payload.ownerId || '');
                response.setTopic(payload.topic);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomPayload', e, callback);
            }
        }),
        roomQRCode: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomQRCode()');
            try {
                const roomId = call.request.getId();
                const qrcode = yield puppet.roomQRCode(roomId);
                const response = new grpc_2.RoomQRCodeResponse();
                response.setQrcode(qrcode);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomQRCode', e, callback);
            }
        }),
        roomQuit: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomQuit()');
            try {
                const roomId = call.request.getId();
                yield puppet.roomQuit(roomId);
                return callback(null, new grpc_2.RoomQuitResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomQuit', e, callback);
            }
        }),
        roomTopic: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'roomTopic()');
            try {
                const roomId = call.request.getId();
                /**
                 * Set
                 */
                {
                    const topicWrapper = call.request.getTopic();
                    if (topicWrapper) {
                        const topic = topicWrapper.getValue();
                        yield puppet.roomTopic(roomId, topic);
                        return callback(null, new grpc_2.RoomTopicResponse());
                    }
                }
                /**
                 * Get
                 */
                const topic = yield puppet.roomTopic(roomId);
                const topicWrapper = new grpc_2.StringValue();
                topicWrapper.setValue(topic);
                const response = new grpc_2.RoomTopicResponse();
                response.setTopic(topicWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomTopic', e, callback);
            }
        }),
        start: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'start()');
            void call;
            try {
                yield puppet.start();
                return callback(null, new grpc_2.StartResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('start', e, callback);
            }
        }),
        stop: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'stop()');
            void call;
            try {
                if (eventStreamManager.busy()) {
                    eventStreamManager.stop();
                }
                else {
                    config_1.log.error('PuppetServiceImpl', 'stop() eventStreamManager is not busy?');
                }
                yield puppet.stop();
                return callback(null, new grpc_2.StopResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('stop', e, callback);
            }
        }),
        tagContactAdd: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactAdd()');
            try {
                const tagId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.tagContactAdd(tagId, contactId);
                return callback(null, new grpc_2.TagContactAddResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactAdd', e, callback);
            }
        }),
        tagContactDelete: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactDelete()');
            try {
                const tagId = call.request.getId();
                yield puppet.tagContactDelete(tagId);
                return callback(null, new grpc_2.TagContactDeleteResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactDelete', e, callback);
            }
        }),
        tagContactList: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactList()');
            try {
                const contactIdWrapper = call.request.getContactId();
                /**
                 * for a specific contact
                 */
                if (contactIdWrapper) {
                    const contactId = contactIdWrapper.getValue();
                    const tagIdList = yield puppet.tagContactList(contactId);
                    const response = new grpc_2.TagContactListResponse();
                    response.setIdsList(tagIdList);
                    return callback(null, new grpc_2.TagContactListResponse());
                }
                /**
                 * get all tags for all contact
                 */
                const tagIdList = yield puppet.tagContactList();
                const response = new grpc_2.TagContactListResponse();
                response.setIdsList(tagIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactList', e, callback);
            }
        }),
        tagContactRemove: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactRemove()');
            try {
                const tagId = call.request.getId();
                const contactId = call.request.getContactId();
                yield puppet.tagContactRemove(tagId, contactId);
                return callback(null, new grpc_2.TagContactRemoveResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactRemove', e, callback);
            }
        }),
        version: (call, callback) => __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetServiceImpl', 'version() v%s', puppet.version());
            void call;
            try {
                const version = puppet.version();
                const response = new grpc_2.VersionResponse();
                response.setVersion(version);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('version', e, callback);
            }
        }),
    };
    return puppetServerImpl;
}
exports.puppetImplementation = puppetImplementation;
//# sourceMappingURL=puppet-implementation.js.map