"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * File Box
 * https://github.com/huan/file-box
 *
 * 2018 Huan LI <zixia@zixia.net>
 *
 */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const url_1 = __importDefault(require("url"));
const mime_1 = __importDefault(require("mime"));
const stream_1 = require("stream");
const config_1 = require("./config");
const file_box_type_1 = require("./file-box.type");
const misc_1 = require("./misc");
const qrcode_1 = require("./qrcode");
const EMPTY_META_DATA = Object.freeze({});
class FileBox {
    constructor(options) {
        // Only keep `basename` in this.name
        this.name = path_1.default.basename(options.name);
        this.boxType = options.type;
        this.mimeType = mime_1.default.getType(this.name) || undefined;
        switch (options.type) {
            case file_box_type_1.FileBoxType.Buffer:
                if (!options.buffer) {
                    throw new Error('no buffer');
                }
                this.buffer = options.buffer;
                break;
            case file_box_type_1.FileBoxType.File:
                if (!options.path) {
                    throw new Error('no path');
                }
                this.localPath = options.path;
                break;
            case file_box_type_1.FileBoxType.Url:
                if (!options.url) {
                    throw new Error('no url');
                }
                this.remoteUrl = options.url;
                if (options.headers) {
                    this.headers = options.headers;
                }
                break;
            case file_box_type_1.FileBoxType.Stream:
                if (!options.stream) {
                    throw new Error('no stream');
                }
                this.stream = options.stream;
                break;
            case file_box_type_1.FileBoxType.QRCode:
                if (!options.qrCode) {
                    throw new Error('no QR Code');
                }
                this.qrCode = options.qrCode;
                break;
            case file_box_type_1.FileBoxType.Base64:
                if (!options.base64) {
                    throw new Error('no Base64 data');
                }
                this.base64 = options.base64;
                break;
            default:
                throw new Error(`unknown options(type): ${JSON.stringify(options)}`);
        }
    }
    /**
     *
     * Static Properties
     *
     */
    /**
     * Alias for `FileBox.fromUrl()`
     *
     * @alias fromUrl()
     */
    static fromUrl(url, name, headers) {
        if (!name) {
            const parsedUrl = new url_1.default.URL(url);
            name = parsedUrl.pathname;
        }
        const options = {
            headers,
            name,
            type: file_box_type_1.FileBoxType.Url,
            url,
        };
        return new this(options);
    }
    /**
     * Alias for `FileBox.fromFile()`
     *
     * @alias fromFile
     */
    static fromFile(path, name) {
        if (!name) {
            name = path_1.default.parse(path).base;
        }
        const options = {
            name,
            path,
            type: file_box_type_1.FileBoxType.File,
        };
        return new this(options);
    }
    static fromStream(stream, name) {
        const options = {
            name,
            stream,
            type: file_box_type_1.FileBoxType.Stream,
        };
        return new this(options);
    }
    static fromBuffer(buffer, name) {
        const options = {
            buffer,
            name,
            type: file_box_type_1.FileBoxType.Buffer,
        };
        return new this(options);
    }
    /**
     * @param base64
     * @param name the file name of the base64 data
     */
    static fromBase64(base64, name) {
        const options = {
            base64,
            name,
            type: file_box_type_1.FileBoxType.Base64,
        };
        return new this(options);
    }
    /**
     * dataURL: `data:image/png;base64,${base64Text}`,
     */
    static fromDataURL(dataUrl, name) {
        return this.fromBase64(misc_1.dataUrlToBase64(dataUrl), name);
    }
    /**
     *
     * @param qrCode the value of the QR Code. For example: `https://github.com`
     */
    static fromQRCode(qrCode) {
        const options = {
            name: 'qrcode.png',
            qrCode,
            type: file_box_type_1.FileBoxType.QRCode,
        };
        return new this(options);
    }
    /**
     *
     * @static
     * @param {(FileBoxJsonObject | string)} obj
     * @returns {FileBox}
     */
    static fromJSON(obj) {
        if (typeof obj === 'string') {
            obj = JSON.parse(obj);
        }
        let fileBox;
        switch (obj.boxType) {
            case file_box_type_1.FileBoxType.Base64:
                fileBox = FileBox.fromBase64(obj.base64, obj.name);
                break;
            case file_box_type_1.FileBoxType.Url:
                fileBox = FileBox.fromUrl(obj.remoteUrl, obj.name);
                break;
            case file_box_type_1.FileBoxType.QRCode:
                fileBox = FileBox.fromQRCode(obj.qrCode);
                break;
            default:
                throw new Error(`unknown filebox json object{type}: ${JSON.stringify(obj)}`);
        }
        fileBox.metadata = obj.metadata;
        return fileBox;
    }
    static version() {
        return config_1.VERSION;
    }
    get metadata() {
        if (this._metadata) {
            return this._metadata;
        }
        return EMPTY_META_DATA;
    }
    set metadata(data) {
        if (this._metadata) {
            throw new Error('metadata can not be modified after set');
        }
        this._metadata = Object.assign({}, data);
        Object.freeze(this._metadata);
    }
    version() {
        return config_1.VERSION;
    }
    type() {
        return this.boxType;
    }
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.boxType === file_box_type_1.FileBoxType.Url) {
                yield this.syncRemoteName();
            }
        });
    }
    /**
     * @todo use http.get/gets instead of Request
     */
    syncRemoteName() {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition
             *  > Content-Disposition: attachment; filename="cool.html"
             */
            if (this.boxType !== file_box_type_1.FileBoxType.Url) {
                throw new Error('type is not Remote');
            }
            if (!this.remoteUrl) {
                throw new Error('no url');
            }
            const headers = yield misc_1.httpHeadHeader(this.remoteUrl);
            const filename = misc_1.httpHeaderToFileName(headers);
            if (filename) {
                this.name = filename;
            }
            if (!this.name) {
                throw new Error('no name');
            }
            this.mimeType = headers['content-type'] || mime_1.default.getType(this.name) || undefined;
        });
    }
    /**
     *
     * toXXX methods
     *
     */
    toString() {
        return [
            'FileBox#',
            file_box_type_1.FileBoxType[this.boxType],
            '<',
            this.name,
            '>',
        ].join('');
    }
    toJSON() {
        const objCommon = {
            metadata: this.metadata,
            name: this.name,
        };
        let obj;
        switch (this.boxType) {
            case file_box_type_1.FileBoxType.Url:
                if (!this.remoteUrl) {
                    throw new Error('no url');
                }
                const objUrl = {
                    boxType: file_box_type_1.FileBoxType.Url,
                    headers: this.headers,
                    remoteUrl: this.remoteUrl,
                };
                obj = Object.assign(Object.assign({}, objCommon), objUrl);
                break;
            case file_box_type_1.FileBoxType.QRCode:
                if (!this.qrCode) {
                    throw new Error('no qr code');
                }
                const objQRCode = {
                    boxType: file_box_type_1.FileBoxType.QRCode,
                    qrCode: this.qrCode,
                };
                obj = Object.assign(Object.assign({}, objCommon), objQRCode);
                break;
            case file_box_type_1.FileBoxType.Base64:
                if (!this.base64) {
                    throw new Error('no base64 data');
                }
                const objBase64 = {
                    base64: this.base64,
                    boxType: file_box_type_1.FileBoxType.Base64,
                };
                obj = Object.assign(Object.assign({}, objCommon), objBase64);
                break;
            default:
                throw new Error('FileBox.toJSON() can only work on limited FileBoxType(s). See: <https://github.com/huan/file-box/issues/25>');
        }
        return obj;
    }
    toStream() {
        return __awaiter(this, void 0, void 0, function* () {
            let stream;
            switch (this.boxType) {
                case file_box_type_1.FileBoxType.Buffer:
                    stream = this.transformBufferToStream();
                    break;
                case file_box_type_1.FileBoxType.File:
                    stream = this.transformFileToStream();
                    break;
                case file_box_type_1.FileBoxType.Url:
                    stream = yield this.transformUrlToStream();
                    break;
                case file_box_type_1.FileBoxType.Stream:
                    if (!this.stream) {
                        throw new Error('no stream');
                    }
                    stream = this.stream;
                    break;
                case file_box_type_1.FileBoxType.QRCode:
                    if (!this.qrCode) {
                        throw new Error('no QR Code');
                    }
                    stream = yield this.transformQRCodeToStream();
                    break;
                case file_box_type_1.FileBoxType.Base64:
                    if (!this.base64) {
                        throw new Error('no base64 data');
                    }
                    stream = this.transformBase64ToStream();
                    break;
                default:
                    throw new Error('not supported FileBoxType: ' + file_box_type_1.FileBoxType[this.boxType]);
            }
            return stream;
        });
    }
    /**
     * https://stackoverflow.com/a/16044400/1123955
     */
    transformBufferToStream(buffer) {
        const bufferStream = new stream_1.PassThrough();
        bufferStream.end(buffer || this.buffer);
        return bufferStream;
    }
    transformBase64ToStream() {
        if (!this.base64) {
            throw new Error('no base64 data');
        }
        const buffer = Buffer.from(this.base64, 'base64');
        return this.transformBufferToStream(buffer);
    }
    transformFileToStream() {
        if (!this.localPath) {
            throw new Error('no url(path)');
        }
        return fs_1.default.createReadStream(this.localPath);
    }
    transformUrlToStream() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.remoteUrl) {
                    misc_1.httpStream(this.remoteUrl, this.headers)
                        .then(resolve)
                        .catch(reject);
                }
                else {
                    reject(new Error('no url'));
                }
            });
        });
    }
    transformQRCodeToStream() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.qrCode) {
                throw new Error('no QR Code Value found');
            }
            const stream = qrcode_1.qrValueToStream(this.qrCode);
            return stream;
        });
    }
    /**
     * save file
     *
     * @param filePath save file
     */
    toFile(filePath, overwrite = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.boxType === file_box_type_1.FileBoxType.Url) {
                if (!this.mimeType || !this.name) {
                    yield this.syncRemoteName();
                }
            }
            const fullFilePath = path_1.default.resolve(filePath || this.name);
            const exist = fs_1.default.existsSync(fullFilePath);
            if (exist && !overwrite) {
                throw new Error(`FileBox.toFile(${fullFilePath}): file exist. use FileBox.toFile(${fullFilePath}, true) to force overwrite.`);
            }
            const writeStream = fs_1.default.createWriteStream(fullFilePath);
            yield new Promise((resolve, reject) => {
                writeStream
                    .once('close', resolve)
                    .once('error', reject);
                this.pipe(writeStream);
            });
        });
    }
    toBase64() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.boxType === file_box_type_1.FileBoxType.Base64) {
                if (!this.base64) {
                    throw new Error('no base64 data');
                }
                return this.base64;
            }
            const buffer = yield this.toBuffer();
            return buffer.toString('base64');
        });
    }
    /**
     * dataUrl: `data:image/png;base64,${base64Text}',
     */
    toDataURL() {
        return __awaiter(this, void 0, void 0, function* () {
            const base64Text = yield this.toBase64();
            if (!this.mimeType) {
                throw new Error('no mimeType');
            }
            const dataUrl = [
                'data:',
                this.mimeType,
                ';base64,',
                base64Text,
            ].join('');
            return dataUrl;
        });
    }
    toBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.boxType === file_box_type_1.FileBoxType.Buffer) {
                if (!this.buffer) {
                    throw new Error('no buffer!');
                }
                return this.buffer;
            }
            const stream = new stream_1.PassThrough();
            this.pipe(stream);
            const buffer = yield misc_1.streamToBuffer(stream);
            return buffer;
        });
    }
    toQRCode() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.boxType === file_box_type_1.FileBoxType.QRCode) {
                if (!this.qrCode) {
                    throw new Error('no QR Code!');
                }
                return this.qrCode;
            }
            const buf = yield this.toBuffer();
            const qrValue = yield qrcode_1.bufferToQrValue(buf);
            return qrValue;
        });
    }
    /**
     *
     * toXXX methods END
     *
     */
    pipe(destination) {
        this.toStream().then(stream => stream.pipe(destination)).catch(e => destination.emit('error', e));
        return destination;
    }
}
exports.FileBox = FileBox;
exports.default = FileBox;
//# sourceMappingURL=file-box.js.map