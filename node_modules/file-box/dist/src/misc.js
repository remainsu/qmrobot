"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = __importDefault(require("url"));
function dataUrlToBase64(dataUrl) {
    const dataList = dataUrl.split(',');
    return dataList[dataList.length - 1];
}
exports.dataUrlToBase64 = dataUrlToBase64;
/**
 * Get http headers for specific `url`
 * follow 302 redirection for max `REDIRECT_TTL` times.
 *
 * @credit https://stackoverflow.com/a/43632171/1123955
 */
function httpHeadHeader(url) {
    return __awaiter(this, void 0, void 0, function* () {
        let REDIRECT_TTL = 7;
        while (true) {
            if (REDIRECT_TTL-- <= 0) {
                throw new Error(`ttl expired! too many(>${REDIRECT_TTL}) 302 redirections.`);
            }
            const res = yield _headHeader(url);
            if (!/^3/.test(String(res.statusCode))) {
                return res.headers;
            }
            // console.log('302 found for ' + url)
            if (!res.headers.location) {
                throw new Error('302 found but no location!');
            }
            url = res.headers.location;
        }
        function _headHeader(destUrl) {
            return __awaiter(this, void 0, void 0, function* () {
                const parsedUrl = url_1.default.parse(destUrl);
                const options = Object.assign(Object.assign({}, parsedUrl), { method: 'HEAD' });
                let request;
                if (parsedUrl.protocol === 'https:') {
                    request = https_1.default.request;
                }
                else if (parsedUrl.protocol === 'http:') {
                    request = http_1.default.request;
                }
                else {
                    throw new Error('unknown protocol: ' + parsedUrl.protocol);
                }
                return new Promise((resolve, reject) => {
                    request(options, resolve)
                        .on('error', reject)
                        .end();
                });
            });
        }
    });
}
exports.httpHeadHeader = httpHeadHeader;
function httpHeaderToFileName(headers) {
    const contentDisposition = headers['content-disposition'];
    if (!contentDisposition) {
        return null;
    }
    // 'content-disposition': 'attachment; filename=db-0.0.19.zip'
    const matches = contentDisposition.match(/attachment; filename="?(.+[^"])"?$/i);
    if (matches && matches[1]) {
        return matches[1];
    }
    return null;
}
exports.httpHeaderToFileName = httpHeaderToFileName;
function httpStream(url, headers = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        /* eslint node/no-deprecated-api: off */
        // FIXME:
        const parsedUrl = url_1.default.parse(url);
        const protocol = parsedUrl.protocol;
        let options;
        let get;
        if (!protocol) {
            throw new Error('protocol is empty');
        }
        if (protocol.match(/^https:/i)) {
            get = https_1.default.get;
            options = parsedUrl;
            options.agent = https_1.default.globalAgent;
        }
        else if (protocol.match(/^http:/i)) {
            get = http_1.default.get;
            options = parsedUrl;
            options.agent = http_1.default.globalAgent;
        }
        else {
            throw new Error('protocol unknown: ' + protocol);
        }
        options.headers = Object.assign(Object.assign({}, options.headers), headers);
        const res = yield new Promise(resolve => get(options, resolve));
        return res;
    });
}
exports.httpStream = httpStream;
function streamToBuffer(stream) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const bufferList = [];
            stream.once('error', reject);
            stream.once('end', () => {
                const fullBuffer = Buffer.concat(bufferList);
                resolve(fullBuffer);
            });
            stream.on('data', buffer => bufferList.push(buffer));
        });
    });
}
exports.streamToBuffer = streamToBuffer;
//# sourceMappingURL=misc.js.map