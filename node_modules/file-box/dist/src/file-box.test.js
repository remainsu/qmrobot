#!/usr/bin/env ts-node
"use strict";
/* eslint @typescript-eslint/no-unused-vars:off */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
require("reflect-metadata");
const tstest_1 = require("tstest");
// import * as sinon from 'sinon'
const file_box_1 = require("./file-box");
const file_box_type_1 = require("./file-box.type");
const requiredMetadataKey = Symbol('required');
const tstest = {
    classFixture() {
        return (constructor) => {
            console.info(constructor.name);
            console.info(constructor.prototype.name);
        };
    },
    methodFixture() {
        return (..._
        // target      : Object,
        // propertyKey : string,
        // descriptor  : PropertyDescriptor,
        ) => {
            console.info('@fixture()');
        };
    },
    parameterFixture() {
        return (target, propertyKey, parameterIndex) => {
            console.info(propertyKey);
            const existingRequiredParameters = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
            existingRequiredParameters.push(parameterIndex);
            Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);
        };
    },
};
tstest_1.test('File smoke testing', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const box = file_box_1.FileBox.fromFile('x');
    t.ok(box);
}));
let FixtureFileBox = class FixtureFileBox {
    static localFileFixutre() {
        return {
            content: 'T',
            name: 'test.txt',
            size: '1',
            type: 'plain/text',
        };
    }
};
__decorate([
    tstest.methodFixture(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], FixtureFileBox, "localFileFixutre", null);
FixtureFileBox = __decorate([
    tstest.classFixture()
], FixtureFileBox);
exports.FixtureFileBox = FixtureFileBox;
// tslint:disable:max-classes-per-file
class TestFileBox {
    static testFileCreateLocal(localFileFixture) {
        const file = file_box_1.FileBox.fromFile(localFileFixture);
        tstest_1.test('File.createLocal()', (t) => __awaiter(this, void 0, void 0, function* () {
            t.ok(file, 'ok');
        }));
        tstest_1.test('File.fromRemote()', (t) => __awaiter(this, void 0, void 0, function* () {
            const URL = 'http://httpbin.org/response-headers?Content-Type=text/plain;%20charset=UTF-8&Content-Disposition=attachment;%20filename%3d%22test.json%22';
            assert_1.default(URL);
            t.pass('ok');
        }));
    }
}
__decorate([
    __param(0, tstest.parameterFixture()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], TestFileBox, "testFileCreateLocal", null);
exports.TestFileBox = TestFileBox;
tstest_1.test('toBase64()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const BASE64_DECODED = 'FileBoxBase64\n';
    const BASE64_ENCODED = 'RmlsZUJveEJhc2U2NAo=';
    const fileBox = file_box_1.FileBox.fromBase64(BASE64_ENCODED, 'test.txt');
    const base64 = yield fileBox.toBase64();
    t.equal(base64, BASE64_ENCODED, 'should get base64 back');
    const text = Buffer.from(base64, 'base64').toString();
    t.equal(text, BASE64_DECODED, 'should get the text right');
}));
tstest_1.test('fromBuffer() & toBase64()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const BASE64_ENCODED = 'RmlsZUJveEJhc2U2NAo=';
    const buffer = Buffer.from(BASE64_ENCODED, 'base64');
    const fileBox = file_box_1.FileBox.fromBuffer(buffer, 'test.txt');
    const base64 = yield fileBox.toBase64();
    t.equal(base64, BASE64_ENCODED, 'should get base64 back from buffer');
}));
tstest_1.test('syncRemoteName()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const URL = 'http://httpbin.org/response-headers?Content-Disposition=attachment;%20filename%3d%22test.txt%22&filename=test.txt';
    const EXPECTED_NAME_FROM_URL = 'response-headers';
    const EXPECTED_TYPE_FROM_URL = undefined;
    const EXPECTED_NAME_FROM_HEADER = 'test.txt';
    const EXPECTED_TYPE_FROM_HEADER = 'application/json';
    const fileBox = file_box_1.FileBox.fromUrl(URL);
    t.equal(fileBox.name, EXPECTED_NAME_FROM_URL, 'should get the name from url');
    t.equal(fileBox.mimeType, EXPECTED_TYPE_FROM_URL, 'should get the mime type from url');
    yield fileBox.syncRemoteName();
    t.equal(fileBox.name, EXPECTED_NAME_FROM_HEADER, 'should get the name from remote header');
    t.equal(fileBox.mimeType, EXPECTED_TYPE_FROM_HEADER, 'should get the mime type from remote http header');
}));
tstest_1.test('fromURL() deal with url with querystring', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const URL = 'https://zixia.net/a.jpg?name=value&t=1324';
    const EXPECTED_NAME = 'a.jpg';
    const fileBox = file_box_1.FileBox.fromUrl(URL);
    t.equal(fileBox.name, EXPECTED_NAME, 'should get basename from url with querystring');
}));
tstest_1.test('toDataURL()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const FILE_PATH = 'tests/fixtures/data.bin';
    const EXPECTED_DATA_URL = 'data:application/octet-stream;base64,dGVzdA==';
    const fileBox = file_box_1.FileBox.fromFile(FILE_PATH);
    const dataUrl = yield fileBox.toDataURL();
    t.equal(dataUrl, EXPECTED_DATA_URL, 'should get the data url right');
}));
tstest_1.test('toString()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const FILE_PATH = 'tests/fixtures/data.bin';
    const EXPECT_STRING = 'FileBox#File<data.bin>';
    const fileBox = file_box_1.FileBox.fromFile(FILE_PATH);
    t.equal(fileBox.toString(), EXPECT_STRING, 'should get the toString() result');
}));
tstest_1.test('toBuffer()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const FILE_PATH = 'tests/fixtures/data.bin';
    const EXPECT_STRING = 'test';
    const fileBox = file_box_1.FileBox.fromFile(FILE_PATH);
    const buffer = yield fileBox.toBuffer();
    t.equal(buffer.toString(), EXPECT_STRING, 'should get the toBuffer() result');
}));
tstest_1.test('metadata', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const FILE_PATH = 'tests/fixtures/data.bin';
    const EXPECTED_NAME = 'myname';
    const EXPECTED_AGE = 'myage';
    const EXPECTED_MOL = 42;
    // interface MetadataType {
    //   metaname : string,
    //   metaage  : number,
    //   metaobj: {
    //     mol: number,
    //   }
    // }
    const EXPECTED_METADATA = {
        metaage: EXPECTED_AGE,
        metaname: EXPECTED_NAME,
        metaobj: {
            mol: EXPECTED_MOL,
        },
    };
    const fileBox = file_box_1.FileBox.fromFile(FILE_PATH);
    t.deepEqual(fileBox.metadata, {}, 'should get a empty {} if not set');
    t.doesNotThrow(() => {
        fileBox.metadata = EXPECTED_METADATA;
    }, 'should not throw for set metadata for the first time');
    t.throws(() => {
        fileBox.metadata = EXPECTED_METADATA;
    }, 'should throw for set metadata again');
    t.throws(() => {
        fileBox.metadata.mol = EXPECTED_MOL;
    }, 'should throw for change value of a property on metadata');
    t.deepEqual(fileBox.metadata, EXPECTED_METADATA, 'should get the metadata');
}));
tstest_1.test('fromQRCode()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const QRCODE_VALUE = 'hello, world!';
    const EXPECTED_QRCODE_IMAGE_BASE64 = [
        'iVBORw0KGgoAAAANSUhEUgAAAHQAAAB0CAYAAABUmhYnAAAAAklEQVR4AewaftIAAAKcSURBVO3BQY7',
        'cQAwEwSxC//9yeo88NSBIsx7TjIg/WGMUa5RijVKsUYo1SrFGKdYoxRqlWKMUa5RijVKsUYo1SrFGKd',
        'YoxRrl4qEk/CaVkyTcoXKShN+k8kSxRinWKMUa5eJlKm9Kwh0qn6TypiS8qVijFGuUYo1y8WFJuEPlj',
        'iR0Kl0SOpUuCZ3KHUm4Q+WTijVKsUYp1igXw6n8T4o1SrFGKdYoF8MloVOZrFijFGuUYo1y8WEq3yQJ',
        'ncoTKt+kWKMUa5RijXLxsiR8M5UuCZ3KSRK+WbFGKdYoxRrl4iGVf5nKicq/pFijFGuUYo0Sf/BAEjq',
        'VLglvUnkiCZ3KSRLepPJJxRqlWKMUa5SLlyXhROU3JaFT6ZJwonKShCeS0Kk8UaxRijVKsUaJP3hREj',
        'qVO5JwotIloVO5Iwl3qJwk4Q6VNxVrlGKNUqxRLv6yJJyodEl4Igl3qHRJ6FTuUPmkYo1SrFGKNcrFQ',
        '0k4ScITSehUuiScJKFT6ZLQqXRJuEPljiR0Kk8Ua5RijVKsUS4eUvkmSbhDpUvCHUk4UflNxRqlWKMU',
        'a5SLh5Lwm1Q6lS4JdyThCZWTJJyovKlYoxRrlGKNcvEylTcl4SQJnUqXhCdUuiScJOFvKtYoxRqlWKN',
        'cfFgS7lB5k0qXhDuS0Kl0SehUTpLQJaFTeaJYoxRrlGKNcjFcEjqVJ5JwkoROpVP5pGKNUqxRijXKxX',
        '8mCScqXRJOVE6S0Kl8UrFGKdYoxRrl4sNUPknlDpUuCV0SOpWTJHyTYo1SrFGKNcrFy5Lwm5LQqXQqX',
        'RI6lZMkdConKidJ6FTeVKxRijVKsUaJP1hjFGuUYo1SrFGKNUqxRinWKMUapVijFGuUYo1SrFGKNUqx',
        'RinWKMUa5Q8Ztu740xD9iQAAAABJRU5ErkJggg==',
    ].join('');
    const fileBox = file_box_1.FileBox.fromQRCode(QRCODE_VALUE);
    const base64Text = yield fileBox.toBase64();
    t.equal(base64Text, EXPECTED_QRCODE_IMAGE_BASE64, 'should encode QR Code value to expected image');
}));
tstest_1.test('toQRCode()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const QRCODE_IMAGE_BASE64 = [
        'iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAQMAAACXljzdAAAABlBMVEX///8AAABVwtN+AAAA',
        'CXBIWXMAAA7EAAAOxAGVKw4bAAAA7klEQVRYw+2WsQ3EIAxFjShSMgKjZLRktIzCCJQpIv7Z',
        'hCiXO/qzT/wCWXo0X3wbEw0NWVaEKM187KHW2QLZ+AhpXovfQ+J6skEWHELqBa5NEeCwR7iS',
        'V7BDzuzAiZ9eqn5IWjfWXHf7VCO5tPAM6U9AjSRideyHFn4FiuvDqV5CM9rZXuF2pZmIAjZy',
        'x4S0MDdBxEmu3TrliPf7iglPvuLlRydfU3P70UweCSK+ZYK0mUg1O4AVcv0/8itGkC7SdiTH',
        '0+Mz19oJZ4NkhhSPbIhQkQGI8u1HJzmzs7p7pzNAru2pJb6z8ykkQ0P/pheK6vjurjf7+wAA',
        'AABJRU5ErkJggg==',
    ].join('');
    const EXPECTED_QRCODE_TEXT = 'hello, world!';
    const fileBox = file_box_1.FileBox.fromBase64(QRCODE_IMAGE_BASE64, 'qrcode.png');
    const qrCodeValue = yield fileBox.toQRCode();
    t.equal(qrCodeValue, EXPECTED_QRCODE_TEXT, 'should decode qrcode image base64 to qr code value');
}));
tstest_1.test('toJSON()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    // const BASE64_DECODED = 'FileBoxBase64\n'
    const BASE64_ENCODED = 'RmlsZUJveEJhc2U2NAo=';
    const BASE64_FILENAME = 'test.txt';
    const EXPECTED_JSON_TEXT = '{"metadata":{},"name":"test.txt","base64":"RmlsZUJveEJhc2U2NAo=","boxType":1}';
    const fileBox = file_box_1.FileBox.fromBase64(BASE64_ENCODED, BASE64_FILENAME);
    const jsonText = JSON.stringify(fileBox);
    t.equal(jsonText, EXPECTED_JSON_TEXT, 'should get expected json text');
    const newFileBox = file_box_1.FileBox.fromJSON(jsonText);
    const newBase64 = yield newFileBox.toBase64();
    t.equal(newBase64, BASE64_ENCODED, 'should get base64 back');
}));
tstest_1.test('toJSON() for not supported type', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const BASE64_ENCODED = 'RmlsZUJveEJhc2U2NAo=';
    const buffer = Buffer.from(BASE64_ENCODED, 'base64');
    const fileBox = file_box_1.FileBox.fromBuffer(buffer, 'test.txt');
    t.equal(fileBox.type(), file_box_type_1.FileBoxType.Buffer, 'should get type() as Buffer');
    t.throws(() => JSON.stringify(fileBox), 'should throw for buffer type of FileBox');
}));
//# sourceMappingURL=file-box.test.js.map