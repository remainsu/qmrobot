"use strict";
// https://github.com/Microsoft/TypeScript/issues/14151#issuecomment-280812617
// if (!Symbol.asyncIterator) {
//   (<any>Symbol).asyncIterator =  Symbol.for('Symbol.asyncIterator')
// }
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const storage_1 = require("./storage");
exports.NAMESPACE_MULTIPLEX_SEPRATOR = '\r';
exports.NAMESPACE_KEY_SEPRATOR = '\n';
const NAMESPACE_MULTIPLEX_SEPRATOR_REGEX = new RegExp(exports.NAMESPACE_MULTIPLEX_SEPRATOR);
const NAMESPACE_KEY_SEPRATOR_REGEX = new RegExp(exports.NAMESPACE_KEY_SEPRATOR);
class MemoryCard {
    constructor(options) {
        config_1.log.verbose('MemoryCard', 'constructor(%s)', JSON.stringify(options));
        if (typeof options === 'string') {
            options = { name: options };
        }
        this.options = options;
        this.name = options && options.name;
        if (options && options.multiplex) {
            this.parent = options.multiplex.parent;
            this.payload = this.parent.payload;
            this.multiplexNameList = [
                ...this.parent.multiplexNameList,
                options.multiplex.name,
            ];
            this.storage = undefined;
        }
        else {
            // payload should be undefined before load()
            this.payload = undefined;
            this.multiplexNameList = [];
            this.storage = this.getStorage();
        }
    }
    fromJSON(textOrObj) {
        config_1.log.verbose('MemoryCard', 'fromJSON(...)');
        let jsonObj;
        if (typeof textOrObj === 'string') {
            jsonObj = JSON.parse(textOrObj);
        }
        else {
            jsonObj = textOrObj;
        }
        const card = new MemoryCard(jsonObj.options);
        card.payload = jsonObj.payload;
        return card;
    }
    static multiplex(memory, name) {
        config_1.log.verbose('MemoryCard', 'static multiplex(%s, %s)', memory, name);
        // if (!memory.options) {
        //   throw new Error('can not multiplex a un-named MemoryCard')
        // }
        const mpMemory = new this(Object.assign(Object.assign({}, memory.options), { multiplex: {
                name,
                parent: memory,
            } }));
        return mpMemory;
    }
    toString() {
        let mpString = '';
        if (this.multiplexNameList.length > 0) {
            mpString = this.multiplexNameList
                .map(mpName => `.multiplex(${mpName})`)
                .join('');
        }
        const name = this.options && this.options.name
            ? this.options.name.toString()
            : '';
        return `MemoryCard<${name}>${mpString}`;
    }
    version() {
        return config_1.VERSION;
    }
    getStorage() {
        config_1.log.verbose('MemoryCard', 'getStorage() for storage type: %s', (this.options
            && this.options.storageOptions
            && this.options.storageOptions.type) || 'N/A');
        if (!this.options) {
            return;
        }
        const storage = storage_1.getStorage(this.options.name, this.options.storageOptions);
        return storage;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', 'load() from storage: %s', this.storage || 'N/A');
            if (this.isMultiplex()) {
                config_1.log.warn('MemoryCard', 'load() should not be called on a multiplex MemoryCard. NOOP');
                return;
            }
            if (this.payload) {
                throw new Error('memory had already loaded before.');
            }
            if (this.storage) {
                this.payload = yield this.storage.load();
            }
            else {
                config_1.log.verbose('MemoryCard', 'load() no storage');
                this.payload = {};
            }
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isMultiplex()) {
                if (!this.parent) {
                    throw new Error('multiplex memory no parent');
                }
                return this.parent.save();
            }
            config_1.log.verbose('MemoryCard', '<%s>%s save() to %s', this.name || '', this.multiplexPath(), this.storage || 'N/A');
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            if (!this.storage) {
                config_1.log.verbose('MemoryCard', 'save() no storage, NOOP');
                return;
            }
            yield this.storage.save(this.payload);
        });
    }
    /**
     *
     * Multiplexing related functions START
     *
     */
    isMultiplexKey(key) {
        if (NAMESPACE_MULTIPLEX_SEPRATOR_REGEX.test(key)
            && NAMESPACE_KEY_SEPRATOR_REGEX.test(key)) {
            const namespace = this.multiplexNamespace();
            return key.startsWith(namespace);
        }
        return false;
    }
    multiplexNamespace() {
        if (!this.isMultiplex()) {
            throw new Error('not a multiplex memory');
        }
        const namespace = exports.NAMESPACE_MULTIPLEX_SEPRATOR
            + this.multiplexNameList.join(exports.NAMESPACE_MULTIPLEX_SEPRATOR);
        return namespace;
    }
    resolveKey(name) {
        if (this.isMultiplex()) {
            const namespace = this.multiplexNamespace();
            return [
                namespace,
                name,
            ].join(exports.NAMESPACE_KEY_SEPRATOR);
        }
        else {
            return name;
        }
    }
    isMultiplex() {
        return this.multiplexNameList.length > 0;
    }
    multiplexPath() {
        return this.multiplexNameList.join('/');
    }
    /**
     * @deprecated use multiplex() instead
     * @hidden
     */
    sub(name) {
        config_1.log.warn('MemoryCard', 'sub() DEPRECATED, use multiplex() instead');
        return this.multiplex(name);
    }
    multiplex(name) {
        config_1.log.verbose('MemoryCard', 'multiplex(%s)', name);
        // FIXME: as any ?
        return this.constructor.multiplex(this, name);
    }
    /**
     *
     * Multiplexing related functions END
     *
     */
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', 'destroy() storage: %s', this.storage || 'N/A');
            if (this.isMultiplex()) {
                throw new Error('can not destroy on a multiplexed memory');
            }
            yield this.clear();
            if (this.storage) {
                yield this.storage.destroy();
                this.storage = undefined;
            }
            // to prevent to use a destroied card
            this.payload = undefined;
        });
    }
    /**
     *
     * ES6 Map API (Async Version)
     *
     * BEGIN
     *
     */
    /**
     * size
     */
    get size() {
        config_1.log.verbose('MemoryCard', '<%s> size', this.multiplexPath());
        if (!this.payload) {
            throw new Error('no payload, please call load() first.');
        }
        let count;
        if (this.isMultiplex()) {
            count = Object.keys(this.payload)
                .filter(key => this.isMultiplexKey(key))
                .length;
        }
        else {
            count = Object.keys(this.payload).length;
        }
        return Promise.resolve(count);
    }
    get(name) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', '<%s> get(%s)', this.multiplexPath(), name);
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            const key = this.resolveKey(name);
            return this.payload[key];
        });
    }
    set(name, data) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', '<%s> set(%s, %s)', this.multiplexPath(), name, data);
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            const key = this.resolveKey(name);
            this.payload[key] = data;
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            config_1.log.verbose('MemoryCard', '<%s> *[Symbol.asyncIterator]()', this.multiplexPath());
            yield __await(yield* __asyncDelegator(__asyncValues(this.entries())));
        });
    }
    entries() {
        return __asyncGenerator(this, arguments, function* entries_1() {
            var e_1, _a;
            config_1.log.verbose('MemoryCard', '<%s> *entries()', this.multiplexPath());
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            try {
                for (var _b = __asyncValues(this.keys()), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const relativeKey = _c.value;
                    const absoluteKey = this.resolveKey(relativeKey);
                    const data = this.payload[absoluteKey];
                    const pair = [relativeKey, data];
                    yield yield __await(pair);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', '<%s> clear()', this.multiplexPath());
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            if (this.isMultiplex()) {
                for (const key in this.payload) {
                    if (this.isMultiplexKey(key)) {
                        delete this.payload[key];
                    }
                }
            }
            else {
                this.payload = {};
            }
        });
    }
    delete(name) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', '<%s> delete(%s)', this.multiplexPath(), name);
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            const key = this.resolveKey(name);
            delete this.payload[key];
        });
    }
    has(key) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('MemoryCard', '<%s> has(%s)', this.multiplexPath(), key);
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            const absoluteKey = this.resolveKey(key);
            return absoluteKey in this.payload;
        });
    }
    keys() {
        return __asyncGenerator(this, arguments, function* keys_1() {
            config_1.log.verbose('MemoryCard', '<%s> keys()', this.multiplexPath());
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            for (const key of Object.keys(this.payload)) {
                // console.log('key', key)
                if (this.isMultiplex()) {
                    if (this.isMultiplexKey(key)) {
                        const namespace = this.multiplexNamespace();
                        // `+1` means there's another NAMESPACE_KEY_SEPRATOR we need to trim
                        const mpKey = key.substr(namespace.length + 1);
                        yield yield __await(mpKey);
                    }
                    continue;
                }
                yield yield __await(key);
            }
        });
    }
    values() {
        return __asyncGenerator(this, arguments, function* values_1() {
            var e_2, _a;
            config_1.log.verbose('MemoryCard', '<%s> values()', this.multiplexPath());
            if (!this.payload) {
                throw new Error('no payload, please call load() first.');
            }
            try {
                for (var _b = __asyncValues(this.keys()), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const relativeKey = _c.value;
                    const absoluteKey = this.resolveKey(relativeKey);
                    yield yield __await(this.payload[absoluteKey]);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
}
exports.MemoryCard = MemoryCard;
/**
 *
 *
 * Static
 *
 *
 */
MemoryCard.VERSION = config_1.VERSION;
exports.default = MemoryCard;
//# sourceMappingURL=memory-card.js.map