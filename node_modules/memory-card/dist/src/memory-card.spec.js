#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-shadowed-variable
const blue_tape_1 = __importDefault(require("blue-tape"));
const fixtures_1 = require("../tests/fixtures");
const memory_card_1 = require("./memory-card");
blue_tape_1.default('smoke testing', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const card = new memory_card_1.MemoryCard();
    yield card.load();
    t.equal(yield card.size, 0, 'init with 0');
    yield card.set('a', 'b');
    t.equal(yield card.size, 1, 'size with 1');
    t.equal(yield card.get('a'), 'b', 'get key a with value b');
    yield card.clear();
    t.equal(yield card.size, 0, 'clear reset to 0');
}));
blue_tape_1.default('storage file load/save', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const EXPECTED_KEY = 'key';
    const EXPECTED_VAL = 'val';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    yield card.load();
    yield card.set(EXPECTED_KEY, EXPECTED_VAL);
    yield card.save();
    const cardB = new memory_card_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    yield cardB.load();
    t.equal(yield cardB.get(EXPECTED_KEY), EXPECTED_VAL, 'should get val back from file');
    yield card.destroy();
    yield cardB.destroy();
}));
blue_tape_1.default.skip('storage aws s3 load/save', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const EXPECTED_KEY = 'key';
    const EXPECTED_VAL = 'val';
    const NAME = Math.random().toString().substr(2);
    const storageOptions = {
        accessKeyId: fixtures_1.AWS_SETTING.ACCESS_KEY_ID,
        bucket: fixtures_1.AWS_SETTING.BUCKET,
        region: fixtures_1.AWS_SETTING.REGION,
        secretAccessKey: fixtures_1.AWS_SETTING.SECRET_ACCESS_KEY,
        type: 's3',
    };
    const card = new memory_card_1.MemoryCard({
        name: NAME,
        storageOptions,
    });
    yield card.load();
    yield card.set(EXPECTED_KEY, EXPECTED_VAL);
    yield card.save();
    const cardB = new memory_card_1.MemoryCard({
        name: NAME,
        storageOptions,
    });
    yield cardB.load();
    t.equal(yield cardB.get(EXPECTED_KEY), EXPECTED_VAL, 'should get val back from s3');
    yield card.destroy();
    yield cardB.destroy();
}));
blue_tape_1.default('save() throw exception before load()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    try {
        yield card.save();
        t.fail('should not call save() success');
    }
    catch (e) {
        t.pass('should throw to call save() before load()');
    }
}));
blue_tape_1.default('load() twice should throw error', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({
        name: NAME,
        storageOptions: {
            type: 'file',
        },
    });
    try {
        yield card.load();
        yield card.load();
        t.fail('should not call load() success after twice');
    }
    catch (e) {
        t.pass('should throw to call load() twice');
    }
}));
blue_tape_1.default('instanciate MemoryCard with undefined options should get undefined name', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const UNDEFIEND = undefined;
    const card = new memory_card_1.MemoryCard(UNDEFIEND);
    t.equal(card.name, UNDEFIEND, 'should get undefined as name');
}));
//# sourceMappingURL=memory-card.spec.js.map