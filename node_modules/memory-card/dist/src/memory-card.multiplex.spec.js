#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-shadowed-variable
const blue_tape_1 = __importDefault(require("blue-tape"));
const sinon_1 = __importDefault(require("sinon"));
const memory_card_1 = require("./memory-card");
class MemoryCardTest extends memory_card_1.MemoryCard {
    get payload() {
        return super.payload;
    }
    set payload(data) {
        super.payload = data;
    }
    resolveKey(key) {
        return super.resolveKey(key);
    }
    multiplexPath() {
        return super.multiplexPath();
    }
    isMultiplexKey(key) {
        return super.isMultiplexKey(key);
    }
}
blue_tape_1.default('multiplex set() & get()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const KEY = 'a';
    const VAL = 'b';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({
        name: NAME,
    });
    yield card.load();
    const cardA = card.multiplex('a');
    const cardB = card.multiplex('b');
    t.equal(yield card.size, 0, 'init with 0 for card');
    t.equal(yield cardA.size, 0, 'init with 0 for cardA');
    t.equal(yield cardB.size, 0, 'init with 0 for cardB');
    yield card.set(KEY, VAL);
    t.equal(yield card.size, 1, 'size with 1');
    t.equal(yield cardA.size, 0, 'size with 0 for cardA');
    t.equal(yield cardB.size, 0, 'size with 0 for cardB');
    yield cardA.set(KEY, VAL);
    t.equal(yield card.size, 2, 'card size with 2(include cardA)');
    t.equal(yield cardA.size, 1, 'cardA size with 1');
    t.equal(yield cardB.size, 0, 'cardB size with 0');
    yield cardB.set(KEY, VAL);
    t.equal(yield card.size, 3, 'card size with 3(include cardA & cardB)');
    t.equal(yield cardA.size, 1, 'cardA size with 1');
    t.equal(yield cardB.size, 1, 'cardB size with 1');
    yield cardB.delete('a');
    t.equal(yield card.size, 2, 'card size with 2(include cardA)');
    t.equal(yield cardA.size, 1, 'cardA size with 1');
    t.equal(yield cardB.size, 0, 'cardB size with 0');
    yield cardA.delete('a');
    t.equal(yield card.size, 1, 'size with 1');
    t.equal(yield cardA.size, 0, 'size with 0 for cardA');
    t.equal(yield cardB.size, 0, 'size with 0 for cardB');
    yield card.delete('a');
    t.equal(yield card.size, 0, 'size with 0');
    t.equal(yield cardA.size, 0, 'size with 0 for cardA');
    t.equal(yield cardB.size, 0, 'size with 0 for cardB');
    yield card.destroy();
}));
blue_tape_1.default('multiplex clear()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const KEY = 'a';
    const VAL = 'b';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('a');
    const cardB = card.multiplex('b');
    yield card.set(KEY, VAL);
    yield cardA.set(KEY, VAL);
    yield cardB.set(KEY, VAL);
    t.equal(yield card.size, 3, 'card size with 3(include cardA & cardB)');
    t.equal(yield cardA.size, 1, 'cardA size with 1');
    t.equal(yield cardB.size, 1, 'cardB size with 1');
    yield cardB.clear();
    t.equal(yield card.size, 2, 'card size with 2(include cardA & cardB)');
    t.equal(yield cardA.size, 1, 'cardA size with 1');
    t.equal(yield cardB.size, 0, 'cardB size with 0');
    yield cardA.clear();
    t.equal(yield card.size, 1, 'card size with 1(include cardA & cardB)');
    t.equal(yield cardA.size, 0, 'cardA size with 0');
    t.equal(yield cardB.size, 0, 'cardB size with 0');
    yield card.destroy();
}));
blue_tape_1.default('multiplex deeper than two layers', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const KEY = 'a';
    const VAL = 'b';
    const NAME = Math.random().toString().substr(2);
    const card = new MemoryCardTest({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('a');
    const cardAA = cardA.multiplex('a');
    const cardAAA = cardAA.multiplex('a');
    yield card.set(KEY, VAL);
    yield cardA.set(KEY, VAL);
    yield cardAA.set(KEY, VAL);
    yield cardAAA.set(KEY, VAL);
    // console.log(card.payload)
    t.equal(yield card.size, 4, 'card size with 4(include cardA & cardAA & cardAAA)');
    t.equal(yield cardA.size, 3, 'cardA size with 3');
    t.equal(yield cardAA.size, 2, 'cardAA size with 2');
    t.equal(yield cardAAA.size, 1, 'cardAAA size with 1');
    yield cardAA.delete('a');
    t.equal(yield card.size, 3, 'card size with 4(include cardA & cardAA & cardAAA)');
    t.equal(yield cardA.size, 2, 'cardA size with 3');
    t.equal(yield cardAA.size, 1, 'cardAA size with 1 (include cardAAA)');
    t.equal(yield cardAAA.size, 1, 'cardAAA size with 1');
    yield card.destroy();
}));
blue_tape_1.default('multiplex destroy()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    try {
        yield cardA.destroy();
        t.fail('should throw');
    }
    catch (e) {
        t.pass('should not allow destroy() on multiplexed memory');
    }
}));
blue_tape_1.default('multiplex clear()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const KEY = 'a';
    const VAL = 'b';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    yield card.set(KEY, VAL);
    yield cardA.set(KEY, VAL);
    yield cardA.clear();
    t.equal(yield card.size, 1, 'should keep parent data when clear child(multiplex)');
    t.equal(yield cardA.size, 0, 'should clear the memory');
}));
blue_tape_1.default('multiplex has()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const KEY = 'a';
    const VAL = 'b';
    const KEYA = 'aa';
    const VALA = 'bb';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    yield card.set(KEY, VAL);
    yield cardA.set(KEYA, VALA);
    t.ok(yield card.has(KEY), 'card should has KEY');
    t.notOk(yield card.has(KEYA), 'card should not has KEYA');
    t.ok(yield cardA.has(KEYA), 'cardA should has KEYA');
    t.notOk(yield cardA.has(KEY), 'cardA should not has KEY');
    yield card.destroy();
}));
blue_tape_1.default('multiplex keys()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a, e_2, _b;
    const KEY = 'a';
    const VAL = 'b';
    const KEYA = 'aa';
    const VALA = 'bb';
    const NAME = Math.random().toString().substr(2);
    const card = new MemoryCardTest({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    yield card.set(KEY, VAL);
    yield cardA.set(KEYA, VALA);
    const cardKeys = [];
    const cardAKeys = [];
    try {
        for (var _c = __asyncValues(card.keys()), _d; _d = yield _c.next(), !_d.done;) {
            const key = _d.value;
            cardKeys.push(key);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) yield _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _e = __asyncValues(cardA.keys()), _f; _f = yield _e.next(), !_f.done;) {
            const key = _f.value;
            cardAKeys.push(key);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) yield _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
    t.deepEqual(cardKeys, [KEY, cardA.resolveKey(KEYA)], 'should get keys back for card');
    t.deepEqual(cardAKeys, [KEYA], 'should get keys back for cardA');
}));
blue_tape_1.default('multiplex values()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_3, _g, e_4, _h;
    const KEY = 'key';
    const VAL = 'val';
    const KEYA = 'key-a';
    const VALA = 'val-a';
    const NAME = Math.random().toString().substr(2);
    const card = new memory_card_1.MemoryCard({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    yield card.set(KEY, VAL);
    yield cardA.set(KEYA, VALA);
    const cardValues = [];
    const cardAValues = [];
    try {
        for (var _j = __asyncValues(card.values()), _k; _k = yield _j.next(), !_k.done;) {
            const value = _k.value;
            cardValues.push(value);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_k && !_k.done && (_g = _j.return)) yield _g.call(_j);
        }
        finally { if (e_3) throw e_3.error; }
    }
    try {
        for (var _l = __asyncValues(cardA.values()), _m; _m = yield _l.next(), !_m.done;) {
            const value = _m.value;
            cardAValues.push(value);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_m && !_m.done && (_h = _l.return)) yield _h.call(_l);
        }
        finally { if (e_4) throw e_4.error; }
    }
    t.deepEqual(cardValues, [VAL, VALA], 'should get values back for card');
    t.deepEqual(cardAValues, [VALA], 'should get values back for cardA');
}));
blue_tape_1.default('multiplex entries()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_5, _o, e_6, _p;
    const KEY = 'key';
    const VAL = 'val';
    const KEYA = 'key-a';
    const VALA = 'val-a';
    const NAME = Math.random().toString().substr(2);
    const card = new MemoryCardTest({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    yield card.set(KEY, VAL);
    yield cardA.set(KEYA, VALA);
    const cardKeys = [];
    const cardAKeys = [];
    const cardValues = [];
    const cardAValues = [];
    try {
        for (var _q = __asyncValues(card.entries()), _r; _r = yield _q.next(), !_r.done;) {
            const [key, value] = _r.value;
            cardKeys.push(key);
            cardValues.push(value);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_r && !_r.done && (_o = _q.return)) yield _o.call(_q);
        }
        finally { if (e_5) throw e_5.error; }
    }
    t.deepEqual(cardKeys, [KEY, cardA.resolveKey(KEYA)], 'should get keys back for card');
    t.deepEqual(cardValues, [VAL, VALA], 'should get values back for card');
    try {
        for (var _s = __asyncValues(cardA.entries()), _t; _t = yield _s.next(), !_t.done;) {
            const [key, value] = _t.value;
            cardAKeys.push(key);
            cardAValues.push(value);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_t && !_t.done && (_p = _s.return)) yield _p.call(_s);
        }
        finally { if (e_6) throw e_6.error; }
    }
    // console.log(cardA.payload)
    t.deepEqual(cardAKeys, [KEYA], 'should get keys back for cardA');
    t.deepEqual(cardAValues, [VALA], 'should get values back for cardA');
}));
blue_tape_1.default('multiplex [Symbol.asyncIterator]()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    var e_7, _u, e_8, _v;
    const KEY = 'a';
    const VAL = 'b';
    const KEYA = 'aa';
    const VALA = 'bb';
    const NAME = Math.random().toString().substr(2);
    const card = new MemoryCardTest({ name: NAME });
    yield card.load();
    const cardA = card.multiplex('test');
    yield card.set(KEY, VAL);
    yield cardA.set(KEYA, VALA);
    const cardKeys = [];
    const cardAKeys = [];
    const cardValues = [];
    const cardAValues = [];
    try {
        for (var card_1 = __asyncValues(card), card_1_1; card_1_1 = yield card_1.next(), !card_1_1.done;) {
            const [key, value] = card_1_1.value;
            cardKeys.push(key);
            cardValues.push(value);
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (card_1_1 && !card_1_1.done && (_u = card_1.return)) yield _u.call(card_1);
        }
        finally { if (e_7) throw e_7.error; }
    }
    t.deepEqual(cardKeys, [KEY, cardA.resolveKey(KEYA)], 'should get keys back for card');
    t.deepEqual(cardValues, [VAL, VALA], 'should get values back for card');
    try {
        for (var cardA_1 = __asyncValues(cardA), cardA_1_1; cardA_1_1 = yield cardA_1.next(), !cardA_1_1.done;) {
            const [key, value] = cardA_1_1.value;
            cardAKeys.push(key);
            cardAValues.push(value);
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (cardA_1_1 && !cardA_1_1.done && (_v = cardA_1.return)) yield _v.call(cardA_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    t.deepEqual(cardAKeys, [KEYA], 'should get keys back for cardA');
    t.deepEqual(cardAValues, [VALA], 'should get values back for cardA');
}));
blue_tape_1.default('multiplex toString()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const NAME = Math.random().toString().substr(2);
    const MULTIPLEX_NAME = 'sub';
    const cardNoName = new memory_card_1.MemoryCard({ name: 'test' });
    yield cardNoName.load();
    const cardNoNameA = cardNoName.multiplex(MULTIPLEX_NAME);
    const card = new memory_card_1.MemoryCard({ name: NAME });
    const cardA = card.multiplex(MULTIPLEX_NAME);
    t.equal(cardNoName.toString(), 'MemoryCard<test>', 'should get toString with empty name');
    t.equal(cardNoNameA.toString(), `MemoryCard<test>.multiplex(${MULTIPLEX_NAME})`, 'should get toString with empty name . multiplex(xxx)');
    t.equal(card.toString(), `MemoryCard<${NAME}>`, 'should get toString with name');
    t.equal(cardA.toString(), `MemoryCard<${NAME}>.multiplex(${MULTIPLEX_NAME})`, 'should get toString with name & sub name');
}));
blue_tape_1.default('multiplex multiplexKey()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const SUB_NAME = 'sub-name';
    const SUB_KEY = 'sub-key';
    const NAME = Math.random().toString().substr(2);
    const EXPECTED_ABS_KEY = [
        memory_card_1.NAMESPACE_MULTIPLEX_SEPRATOR,
        SUB_NAME,
        memory_card_1.NAMESPACE_KEY_SEPRATOR,
        SUB_KEY,
    ].join('');
    const card = new MemoryCardTest({ name: NAME });
    yield card.load();
    const cardA = card.multiplex(SUB_NAME);
    t.equal(card.resolveKey(SUB_KEY), SUB_KEY, 'root memory should get the same subKey for their arg');
    t.equal(cardA.resolveKey(SUB_KEY), EXPECTED_ABS_KEY, 'should get subKey for NAME');
    yield card.destroy();
}));
blue_tape_1.default('multiplex isMultiplex()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const NAME = Math.random().toString().substr(2);
    const card = new MemoryCardTest({ name: NAME });
    yield card.load();
    const cardA = card.multiplex(NAME);
    t.equal(card.isMultiplex(), false, 'card is not a sub memory');
    t.equal(cardA.isMultiplex(), true, 'card a is a sub memory');
}));
blue_tape_1.default('multiplex isMultiplexKey()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const NAME = Math.random().toString().substr(2);
    const KEY = Math.random().toString().substr(2);
    const EXPECTED_MULTIPLEX_KEY = [
        memory_card_1.NAMESPACE_MULTIPLEX_SEPRATOR,
        NAME,
        memory_card_1.NAMESPACE_KEY_SEPRATOR,
        KEY,
    ].join('');
    const card = new MemoryCardTest({ name: NAME });
    const cardA = card.multiplex(NAME);
    t.equal(card.isMultiplexKey(KEY), false, 'card should identify normal string as not sub key');
    t.equal(cardA.isMultiplexKey(EXPECTED_MULTIPLEX_KEY), true, 'card a should identify SUB_KEY a sub key');
}));
blue_tape_1.default('multiplex save()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const MEMORY_NAME = Math.random().toString().substr(2);
    const SUB_NAME = Math.random().toString().substr(2);
    const card = new MemoryCardTest({ name: MEMORY_NAME });
    yield card.load();
    const cardA = card.multiplex(SUB_NAME);
    const sandbox = sinon_1.default.createSandbox();
    const stub = sandbox.stub(card, 'save').callsFake(() => __awaiter(void 0, void 0, void 0, function* () { }));
    yield cardA.save();
    t.equal(stub.callCount, 1, 'multiplexed memory should call parent save()');
    yield card.destroy();
    sandbox.restore();
}));
blue_tape_1.default('multiplex multiplexPath()', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const SUB_NAME_A = Math.random().toString().substr(2);
    const SUB_NAME_B = Math.random().toString().substr(2);
    const EXPECTED_SUB_PATH = [SUB_NAME_A, SUB_NAME_B].join('/');
    const card = new MemoryCardTest({ name: 'test' });
    const cardA = card.multiplex(SUB_NAME_A);
    const cardB = cardA.multiplex(SUB_NAME_B);
    t.equal(cardB.multiplexPath(), EXPECTED_SUB_PATH, 'should get sub path right');
}));
//# sourceMappingURL=memory-card.multiplex.spec.js.map