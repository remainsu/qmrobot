/* rx-queue version 0.8.5 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global.window = {}, global.rxjs, global.operators));
}(this, function (exports, rxjs, operators) { 'use strict';

    /**
     * This file was auto generated from scripts/generate-version.sh
     */
    const VERSION = '0.8.5';

    // default set to 500 milliseconds
    const DEFAULT_PERIOD_TIME = 500;
    // https://codepen.io/maindg/pen/xRwGvL
    class RxQueue extends rxjs.Subject {
        constructor(period = DEFAULT_PERIOD_TIME) {
            super();
            this.period = period;
            this.itemList = [];
        }
        next(item) {
            if (this.observers.length > 0) {
                super.next(item);
            }
            else {
                this.itemList.push(item);
            }
        }
        subscribe(nextOrObserver, error, complete) {
            let subscription; // TypeScript strict require strong typing differenciation
            if (typeof nextOrObserver === 'function') {
                subscription = super.subscribe(nextOrObserver, error, complete);
            }
            else {
                subscription = super.subscribe(nextOrObserver);
            }
            this.itemList.forEach(item => this.next(item));
            this.itemList = [];
            return subscription;
        }
        version() {
            return VERSION;
        }
    }

    /**
     * DelayQueue passes all the items and add delays between items.
     * T: item type
     */
    class DelayQueue extends RxQueue {
        /**
         *
         * @param period milliseconds
         */
        constructor(period) {
            super(period);
            this.subject = new rxjs.Subject();
            this.subscription = this.subject.pipe(operators.concatMap(args => rxjs.concat(rxjs.of(args), // emit first item right away
            rxjs.EMPTY.pipe(operators.delay(this.period))))).subscribe((item) => super.next(item));
        }
        next(item) {
            this.subject.next(item);
        }
        unsubscribe() {
            this.subscription.unsubscribe();
            super.unsubscribe();
        }
    }

    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    /**
     * DelayQueueExecutor calls functions one by one with a delay time period between calls.
     */
    class DelayQueueExecutor extends DelayQueue {
        /**
         *
         * @param period milliseconds
         */
        constructor(period) {
            super(period);
            this.delayQueueSubscription = this.subscribe(unit => {
                try {
                    const ret = unit.fn();
                    return unit.resolve(ret);
                }
                catch (e) {
                    return unit.reject(e);
                }
            });
        }
        execute(fn, name) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    const unit = {
                        fn,
                        name: name || fn.name,
                        reject,
                        resolve,
                    };
                    this.next(unit);
                });
            });
        }
        unsubscribe() {
            this.delayQueueSubscription.unsubscribe();
            super.unsubscribe();
        }
    }

    /**
     * DebounceQueue drops a item if there's another one comes in a period of time.
     *
     * T: item type
     */
    class DebounceQueue extends RxQueue {
        /**
         *
         * @param period milliseconds
         */
        constructor(period) {
            super(period);
            this.subject = new rxjs.Subject();
            this.subscription = this.subject.pipe(operators.debounce(() => rxjs.interval(this.period)))
                .subscribe((item) => super.next(item));
        }
        next(item) {
            this.subject.next(item);
        }
        unsubscribe() {
            this.subscription.unsubscribe();
            super.unsubscribe();
        }
    }

    /**
     * ThrottleQueue
     *
     * passes one item and then drop all the following items in a period of time.
     *
     * T: item type
     */
    class ThrottleQueue extends RxQueue {
        /**
         *
         * @param period milliseconds
         */
        constructor(period) {
            super(period);
            this.subject = new rxjs.Subject();
            this.subscription = this.subject.pipe(operators.throttle(() => rxjs.interval(this.period))).subscribe((item) => super.next(item));
        }
        next(item) {
            this.subject.next(item);
        }
        unsubscribe() {
            this.subscription.unsubscribe();
            super.unsubscribe();
        }
    }

    exports.DebounceQueue = DebounceQueue;
    exports.DelayQueue = DelayQueue;
    exports.DelayQueueExector = DelayQueueExecutor;
    exports.DelayQueueExecutor = DelayQueueExecutor;
    exports.RxQueue = RxQueue;
    exports.ThrottleQueue = ThrottleQueue;
    exports.VERSION = VERSION;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
/* https://github.com/huan */
//# sourceMappingURL=rx-queue.es6.umd.js.map
