#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test = require("blue-tape");
// import * as sinon from 'sinon'
const clone_class_1 = require("./clone-class");
const fixture_class_1 = require("../tests/fixtures/fixture-class");
test('cloneClass smoke testing', (t) => __awaiter(this, void 0, void 0, function* () {
    const EXPECTED_NUMBER1 = 1;
    const EXPECTED_NUMBER2 = 2;
    const NewClass1 = clone_class_1.default(fixture_class_1.default);
    const NewClass2 = clone_class_1.default(fixture_class_1.default);
    t.ok(NewClass1.prototype instanceof fixture_class_1.default, 'should extend right');
    t.notEqual(NewClass1, NewClass2, 'NewClass1 should different with NewClass2');
    t.notEqual(NewClass1, fixture_class_1.default, 'NewClass1 should different with FixtureClass');
    NewClass1.staticMethod(EXPECTED_NUMBER1);
    t.equal(NewClass1.staticNumber, EXPECTED_NUMBER1, 'should set static number to EXPECTED_NUMBER1');
    NewClass2.staticMethod(EXPECTED_NUMBER2);
    t.equal(NewClass2.staticNumber, EXPECTED_NUMBER2, 'should set static number to EXPECTED_NUMBER2');
    const nc1 = new NewClass1(EXPECTED_NUMBER1, EXPECTED_NUMBER2);
    const nc2 = new NewClass2(EXPECTED_NUMBER1, EXPECTED_NUMBER2);
    t.ok(nc1 instanceof fixture_class_1.default, 'nc1 should instanceof FixtureClass');
    t.ok(nc1 instanceof NewClass1, 'nc1 should  instanceof NewClass1');
    t.equal(nc1.sum(), EXPECTED_NUMBER1 + EXPECTED_NUMBER1 + EXPECTED_NUMBER2, 'should sum right for 1 + 1 + 2');
    t.equal(nc2.sum(), EXPECTED_NUMBER2 + EXPECTED_NUMBER1 + EXPECTED_NUMBER2, 'should sum right for 2 + 1 + 2');
}));
test('cloneClass return NewClass with Original Name', (t) => __awaiter(this, void 0, void 0, function* () {
    const NewClass = clone_class_1.default(fixture_class_1.default);
    t.equal(NewClass.name, fixture_class_1.default.name, 'should clone the same name for Class');
}));
test('throw error when lowercase static property initilized with defination', (t) => __awaiter(this, void 0, void 0, function* () {
    class Test {
    }
    Test.n = { mof: 42 };
    t.throws(() => clone_class_1.default(Test), 'should throw when the static property initialized with a object in defination');
}));
test('permit static property start with a captial letter to be initilized with defination', (t) => __awaiter(this, void 0, void 0, function* () {
    class Test {
    }
    Test.Data = { mof: 42 };
    t.doesNotThrow(() => clone_class_1.default(Test), 'should not throw when the static property start with a captial letter that initialized with a object in defination');
}));
//# sourceMappingURL=clone-class.spec.js.map